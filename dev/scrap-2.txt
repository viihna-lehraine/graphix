
  // ------------------------------------------------ //

  set(viewportWidth: number, viewportHeight: number): void {
    this.#state.viewportWidth = viewportWidth;
    this.#state.viewportHeight = viewportHeight;
    this.#notify();
  }

  // ------------------------------------------------ //

  subscribe(fn: Subscriber<ClientState>) {
    this.#subscribers.add(fn);
    fn(this.get());
    return () => this.#subscribers.delete(fn);
  }

  // ------------------------------------------------ //

  #notify(): void {
    const state = this.get();

    for (const fn of this.#subscribers) fn(state);
  }
}
// File: frontend/src/app/core/services/index.ts

export { AnimationGroupManager } from './AnimationGroupManager.js';
export { CacheManager } from './CacheManager.js';
export { CanvasStateService } from './state/CanvasStateService.js';
export { ClientStateService } from './state/ClientStateService.js';
export { ErrorHandler } from './ErrorHandler.js';
export { IDBStorageService } from './storage/IDBStorageService.js';
export { LocalStorageService } from './storage/LocalStorageService.js';
export { Logger } from './Logger.js';
export { ResizeManager } from './ResizeManager.js';
export { StateManager } from './state/StateManager.js';
export { StorageManager } from './storage/StorageManager.js';
// File: frontend/src/app/core/services/storage/StorageManager.ts

import type { IStorageService } from '../../../types/index.js';
import { IDBStorageService } from './IDBStorageService.js';
import { LocalStorageService } from './LocalStorageService.js';

// ================================================== //
// ================================================== //

export class StorageManager implements IStorageService {
  static #instance: StorageManager | null = null;

  #backend: IStorageService;

  private constructor(backend: IStorageService) {
    this.#backend = backend;
  }

  static async getInstance(): Promise<StorageManager> {
    if (!StorageManager.#instance) {
      // try IndexedDB, fallback to LocalStorage
      let backend: IStorageService;

      try {
        backend = await IDBStorageService.create();
      } catch (e) {
        backend = new LocalStorageService();
      }

      StorageManager.#instance = new StorageManager(backend);
    }
    return StorageManager.#instance;
  }

  // ================================================ //

  get<T>(key: string): Promise<T | null> {
    return this.#backend.get<T>(key);
  }

  set<T>(key: string, value: T): Promise<void> {
    return this.#backend.set<T>(key, value);
  }

  remove(key: string): Promise<void> {
    return this.#backend.remove(key);
  }

  clear(): Promise<void> {
    return this.#backend.clear();
  }
}
// File: frontend/src/app/core/services/storage/LocalStorageService.ts

import type { IStorageService } from '../../../types/index.js';

// ========================================================= //
// ========================================================= //

export class LocalStorageService implements IStorageService {
  get<T>(key: string): Promise<T | null> {
    return Promise.resolve(
      localStorage.getItem(key) ? JSON.parse(localStorage.getItem(key)!) : null
    );
  }

  set<T>(key: string, value: T): Promise<void> {
    localStorage.setItem(key, JSON.stringify(value));
    return Promise.resolve();
  }

  remove(key: string): Promise<void> {
    localStorage.removeItem(key);
    return Promise.resolve();
  }

  clear(): Promise<void> {
    localStorage.clear();
    return Promise.resolve();
  }
}
// File: frotnend/src/app/core/services/storage/IDBStorageService.ts

import type { IStorageService } from '../../../types/index.js';

export class IDBStorageService implements IStorageService {
  static DB_NAME = 'graphix-app';
  static STORE = 'app-data';

  #db: IDBDatabase;

  private constructor(db: IDBDatabase) {
    this.#db = db;
  }

  // ======================================================= //

  static create(): Promise<IDBStorageService> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(IDBStorageService.DB_NAME, 1);
      request.onupgradeneeded = () => {
        const db = request.result;
        if (!db.objectStoreNames.contains(IDBStorageService.STORE)) {
          db.createObjectStore(IDBStorageService.STORE);
        }
      };
      request.onsuccess = () => {
        resolve(new IDBStorageService(request.result));
      };
      request.onerror = () => {
        reject(request.error);
      };
    });
  }

  // ======================================================= //

  clear(): Promise<void> {
    return new Promise((resolve, reject) => {
      const req = this.#tx('readwrite').clear();
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }

  get<T>(key: string): Promise<T | null> {
    return new Promise((resolve, reject) => {
      const req = this.#tx('readonly').get(key);
      req.onsuccess = () => resolve(req.result ? JSON.parse(req.result) : null);
      req.onerror = () => reject(req.error);
    });
  }

  remove(key: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const req = this.#tx('readwrite').delete(key);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }

  set<T>(key: string, value: T): Promise<void> {
    return new Promise((resolve, reject) => {
      const req = this.#tx('readwrite').put(JSON.stringify(value), key);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }

  // ======================================================= //

  #tx(mode: IDBTransactionMode): IDBObjectStore {
    return this.#db
      .transaction(IDBStorageService.STORE, mode)
      .objectStore(IDBStorageService.STORE);
  }
}
// File: frontend/src/app/core/services/Notifier.ts

import type {
  NotifierLevel,
  NotifierServiceContract
} from '../../types/index.js';

// =================================================== //
// =================================================== //

export class Notifier implements NotifierServiceContract {
  static #instance: Notifier | null = null;

  private constructor() {}

  static getInstance(): Notifier {
    if (!Notifier.#instance) {
      Notifier.#instance = new Notifier();
    }
    return Notifier.#instance;
  }

  // ================================================== //

  notify(message: string, level: NotifierLevel = 'warn'): void {
    switch (level) {
      case 'info':
        alert(`ℹ ${message}`);
        break;
      case 'warn':
        alert(`⚠ ${message}`);
        break;
      case 'error':
        alert(`❌ ${message}`);
        break;
      case 'success':
        alert(`✅ ${message}`);
        break;
    }
  }

  // ================================================== //

  info(message: string): void {
    this.notify(message, 'info');
  }
  warn(message: string): void {
    this.notify(message, 'warn');
  }
  error(message: string): void {
    this.notify(message, 'error');
  }
  success(message: string): void {
    this.notify(message, 'success');
  }
}
// File: frontend/src/app/core/services/CanvasCacheService.ts

import type {
  Cache,
  CacheManagerContract,
  Services
} from '../../types/index.js';

// ======================================================== //
// ======================================================== //

export class CacheManager implements CacheManagerContract {
  static #instance: CacheManager | null = null;

  #cache = {} as Cache;

  #errors: Services['errors'];
  #log: Services['log'];

  // ====================================================== //

  private constructor(errors: Services['errors'], log: Services['log']) {
    try {
      this.#errors = errors;
      this.#log = log;

      if (CacheManager.#instance) {
        throw new Error(
          'CanvasCacheService is a singleton and cannot be instantiated multiple times.'
        );
      }

      CacheManager.#instance = this;
    } catch (error) {
      throw new Error('Unhandled CanvasCacheService initialization error.');
    }
  }

  // ====================================================== //

  public static getInstance(
    errors: Services['errors'],
    log: Services['log']
  ): CacheManager {
    return errors.handleSync(() => {
      if (!CacheManager.#instance) {
        log.info('Creating CanvasCacheService instance.');
        CacheManager.#instance = new CacheManager(errors, log);
      }

      log.info('Returning existing CanvasCacheService instance.');
      return CacheManager.#instance;
    }, 'Unhandled CanvasCacheService getInstance error.');
  }

  // ====================================================== //

  get cachedBgImg(): HTMLImageElement | null {
    return this.#errors.handleSync(() => {
      this.#log.debug('Returning cached canvas background img');
      return this.#cache.bgImg;
    }, 'Unhandled CanvasCacheService cachedBgImg getter error.');
  }

  set cachedBgImg(img: HTMLImageElement | null) {
    this.#errors.handleSync(() => {
      this.#cache.bgImg = img;
    }, 'Unhandled CanvasCacheService cachedBgImg setter error.');
  }

  // ====================================================== //

  clearAll(): void {
    this.#errors.handleSync(() => {
      this.#cache.bgImg = null;
    }, 'Unhandled CanvasCacheService clearAll error.');
  }
}
// File: frontend/src/app/core/services/AnimationGroupManager.ts

import type {
  AnimationGroup,
  AnimationGroupManagerContract
} from '../../types/index.js';

// ================================================== //
// ================================================== //

export class AnimationGroupManager implements AnimationGroupManagerContract {
  static #instance: AnimationGroupManager | null = null;

  #groups: AnimationGroup[] = [];

  private constructor() {}

  static getInstance(): AnimationGroupManager {
    if (!this.#instance) {
      this.#instance = new AnimationGroupManager();
    }
    return this.#instance;
  }

  get groups(): AnimationGroup[] {
    return this.#groups;
  }

  addGroup(group: AnimationGroup): void {
    this.#groups.push(group);
  }

  pause(groupId: string): void {
    const group = this.#groups.find(g => g.id === groupId);
    if (group) group.isPlaying = false;
  }

  play(groupId: string): void {
    const group = this.#groups.find(g => g.id === groupId);
    if (group) group.isPlaying = true;
  }

  removeGroup(groupId: string): void {
    this.#groups = this.#groups.filter(g => g.id !== groupId);
  }

  update(deltaTime: number): void {
    this.#groups.forEach(group => {
      if (!group.isPlaying) return;

      group.layers.forEach(layer => {
        // advance rotation if present
        if (layer.rotation && layer.rotation.direction !== 'n/a') {
          const dirFactor = layer.rotation.direction === 'clockwise' ? 1 : -1;
          layer.rotation.currentAngle =
            (layer.rotation.currentAngle +
              dirFactor * layer.rotation.speed * deltaTime) %
            360;
        }

        // advance GIF frames if applicable
        if (layer.type === 'gif') {
          layer.frameElapsed = (layer.frameElapsed ?? 0) + deltaTime * 1000;

          const frameDuration = 1000 / (layer.animationProps?.frames.rate || 1);

          while (layer.frameElapsed >= frameDuration) {
            layer.frameElapsed -= frameDuration;
            layer.currentFrame =
              ((layer.currentFrame ?? 0) + 1) % layer.gifFrames.length;
          }
        }
      });
    });
  }
}
// File: frontend/src/app/core/services/dom/ResizeManager.ts

import type {
  ResizeManagerContract,
  ResizePlugin,
  Services
} from '../../types/index.js';

// =================================================== //
// =================================================== //

export class ResizeManager implements ResizeManagerContract {
  static #instance: ResizeManager | null = null;

  // #debounceTimeout: number | null = null;
  #plugins: Set<ResizePlugin> = new Set();

  #errors: Services['errors'];
  #log: Services['log'];

  // =================================================== //

  private constructor(errors: Services['errors'], log: Services['log']) {
    try {
      log.info('Initializing ResizeManager...');

      this.#errors = errors;
      this.#log = log;

      this.initialize();

      log.info('ResizeManager initialized successfully.');
    } catch (error) {
      throw new Error(
        `Failed to initialize ResizeManager: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  // =================================================== //

  static getInstance(
    errors: Services['errors'],
    log: Services['log']
  ): ResizeManager {
    try {
      if (!ResizeManager.#instance) {
        ResizeManager.#instance = new ResizeManager(errors, log);
      }

      return ResizeManager.#instance;
    } catch (error) {
      throw new Error(
        `Failed to get ResizeManager instance: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  // =================================================== //

  initialize(): void {
    this.#errors.handleSync(() => {
      this.#log.info('Registering Window Resize event listeners...');

      // window.addEventListener('resize', this.debouncedRunAll);
      document.addEventListener('DOMContentLoaded', this.runAll.bind(this));
    }, 'ResizeManager initialization failed.');
  }

  // =================================================== //

  register(plugin: ResizePlugin): void {
    this.#plugins.add(plugin);
  }

  // =================================================== //

  runAll(): void {
    this.#plugins.forEach(fn => {
      try {
        fn();
      } catch (err) {
        console.error('[ResizeManager] Plugin error:', err);
      }
    });
  }

  // =================================================== //

  unregister(plugin: ResizePlugin): void {
    this.#plugins.delete(plugin);
  }
}
// File: frontend/src/app/core/config/errors.ts

class UserFacingError extends Error {
  constructor(
    message: string,
    public userMessage?: string
  ) {
    super(message);
    this.name = 'UserFacingError';
  }
}

export interface ErrorClasses {
  UserFacingError: typeof UserFacingError;
}

// ================================================== //

export const errorClasses: ErrorClasses = {
  UserFacingError
} as const;
// File: frontend/src/app/core/config/manifest.ts

import type { AssetManifestEntry } from '../../types/index.js';

export async function loadAssetManifest(): Promise<AssetManifestEntry[]> {
  const resp = await fetch('/assets/userManifest.json');
  if (!resp.ok)
    throw new Error(`Failed to load asset manifest: ${resp.statusText}`);
  return resp.json();
}
// File: frontend/src/app/types/index.ts

export type {
  AnimationGroup,
  AnimationProps,
  AssetClass,
  AssetManifestEntry,
  BackgroundAsset,
  BaseAsset,
  BaseVisualLayer,
  BorderAsset,
  Cache,
  CanvasLifecycleEvent,
  CanvasResizeOptions,
  CanvasState,
  ClientState,
  ErrorHandlerOptions,
  FontAsset,
  GifAnimation,
  GifAsset,
  GifFrame,
  GifVisualLayer,
  ImageAsset,
  ImageVisualLayer,
  ListenerRegistration,
  NotifierLevel,
  OverlayAsset,
  OverlayVisualLayer,
  Plugin,
  RedrawPlugin,
  ResizePlugin,
  State,
  StateLifecycleHook,
  StickerAsset,
  StickerVisualLayer,
  Subscriber,
  SupportedAsset,
  TextElement,
  TextVisualLayer,
  UIInitializer,
  VideoVisualLayer,
  VisualLayer
} from './app/index.js';
export type {
  AnimationGroupManagerContract,
  CacheManagerContract,
  CanvasStateServiceContract,
  ClientStateServiceContract,
  ErrorHandlerServiceContract,
  IStorageService,
  NotifierServiceContract,
  LoggerServiceContract,
  RenderingEngineContract,
  ResizeManagerContract,
  StateManagerContract
} from './contracts.js';
export type { TextStyle } from './css.js';
export type {
  AssetData,
  AssetExts,
  AssetManifest,
  AssetTags,
  BaseData,
  ConfigData,
  Data,
  Defaults,
  DomBtnIds,
  DomData,
  DomClasses,
  DomDivIds,
  DomFormIds,
  DomIds,
  DomInputIds,
  ErrorMessages,
  Flags,
  MessageData,
  Paths,
  Regex,
  SupportedExt,
  SupportedExts,
  UnsupportedExt,
  UnsupportedExts
} from './data.js';
export type {
  AppHelpers,
  CanvasHelpers,
  CanvasUtils,
  Core,
  DataHelpers,
  DataUtils,
  DomUtils,
  Helpers,
  IOFunctions,
  MathHelpers,
  MathUtils,
  OverlayFunctions,
  Services,
  TimeHelpers,
  Utilities
} from './functions.js';
// File: frontend/src/app/types/functions.ts

import type { Data, GifAnimation, TextElement, VisualLayer } from './index.js';
import {
  AnimationGroupManager,
  CacheManager,
  ErrorHandler,
  Logger,
  ResizeManager,
  StateManager,
  StorageManager
} from '../core/services/index.js';

// ================================================== //
// ========= CORE FUNCTION OBJECTS ================== //
// ================================================== //

export interface Core {
  data: Required<Data>;
  helpers: Required<Helpers>;
  services: Required<Services>;
  utils: Required<Utilities>;
}

export interface Helpers {
  app: AppHelpers;
  canvas: CanvasHelpers;
  data: DataHelpers;
  math: MathHelpers;
  time: TimeHelpers;
}

export type Services = {
  animationGroupManager: AnimationGroupManager;
  cache: CacheManager;
  errors: ErrorHandler;
  log: Logger;
  resizeManager: ResizeManager;
  stateManager: StateManager;
  storageManager: StorageManager;
};

export interface Utilities {
  canvas: CanvasUtils;
  data: DataUtils;
  dom: DomUtils;
  math: MathUtils;
}

// ================================================== //
// ======= CORE FUNCTION OBJECT PARTIALS ============ //
// ================================================== //

export interface AppHelpers {
  noop: () => void;
}

export interface CanvasHelpers {
  get2DContext: (canvas: HTMLCanvasElement) => CanvasRenderingContext2D;
  getMousePosition(
    canvas: HTMLCanvasElement,
    evt: MouseEvent
  ): {
    x: number;
    y: number;
  };
  isOverResizeHandle(
    mouse: { x: number; y: number },
    elem: TextElement,
    ctx: CanvasRenderingContext2D
  ): boolean;
  isPointInText(
    pt: { x: number; y: number },
    elem: TextElement,
    ctx: CanvasRenderingContext2D
  ): boolean;
  mapBlendMode: (blendMode?: string) => GlobalCompositeOperation;
}

export interface DataHelpers {
  clone: <T>(data: T) => T;
  getFileSizeInKB: (file: File | Blob) => number;
  getFileSHA256: (file: File | Blob) => Promise<string>;
}
export interface MathHelpers {
  weightedRandom: (min: number, max: number, weight: number) => number;
}

export interface TimeHelpers {
  debounce: <T extends (...args: Record<string, unknown>[]) => void>(
    fn: T,
    wait?: number
  ) => (...args: Parameters<T>) => void;
}

export interface CanvasUtils {
  drawVisualLayersToContext(
    ctx: CanvasRenderingContext2D,
    layers: VisualLayer[],
    helpers: Helpers
  ): void;
}

export interface DataUtils {
  detectFileType: (file: File) => Promise<string | undefined>;
}

export interface DomUtils {
  getCssVar: (name: string) => string;
}

export interface MathUtils {
  modulo: (x: number, n: number) => number;
  roundToStep: (x: number, step: number) => number;
  toDegrees: (rad: number) => number;
  toRadians: (deg: number) => number;
}

// ================================================== //

export interface IOFunctions {
  exportGif: (
    layers: VisualLayer[],
    width: number,
    height: number,
    frameCount: number,
    core: Core,
    fileName?: string
  ) => Promise<void>;
  exportStaticFile: (
    layers: VisualLayer[],
    width: number,
    height: number,
    core: Core,
    fileName?: string
  ) => Promise<void>;
  handleDownload(
    targetRef: React.RefObject<HTMLDivElement | null>,
    core: Core,
    fileName?: string
  ): Promise<void>;
  handleUpload: (
    file: File,
    core: Core,
    createGifAnimation: (arrayBuffer: ArrayBuffer) => GifAnimation
  ) => Promise<void>;
}

export interface OverlayFunctions {
  removeExistingOverlay(className: string): void;
  showTxtElemOverlay: (
    canvas: HTMLCanvasElement,
    elem: TextElement,
    index: number,
    core: Core,
    redraw: () => void
  ) => void;
}
// File: frontend/src/app/types/contracts.ts

import type {
  AnimationGroup,
  CanvasState,
  ClientState,
  ErrorHandlerOptions,
  GifAnimation,
  NotifierLevel,
  RedrawPlugin,
  ResizePlugin,
  State,
  StateLifecycleHook,
  Subscriber,
  TextElement,
  VisualLayer
} from './index.js';

// ================================================== //
// ================================================== //
// ================================================== //

export interface AnimationGroupManagerContract {
  addGroup: (group: AnimationGroup) => void;
  removeGroup: (groupId: string) => void;
  pause: (groupId: string) => void;
  play: (groupId: string) => void;
  update(deltaTime: number): void;
}

export interface CacheManagerContract {
  clearAll(): void;
}

export interface ErrorHandlerServiceContract {
  handleAndReturn<T>(
    action: () => T | Promise<T>,
    errorMessage: string,
    options?: ErrorHandlerOptions
  ): T | Promise<T>;
  handleAsync<T>(
    action: () => Promise<T>,
    errorMessage: string,
    options?: ErrorHandlerOptions
  ): Promise<T>;
  handleSync<T>(
    action: () => T,
    errorMessage: string,
    options?: ErrorHandlerOptions
  ): T;
}

export interface LoggerServiceContract {
  debug: (message: string, caller?: string) => void;
  error: (message: string, caller?: string) => void;
  info: (message: string, caller?: string) => void;
  warn: (message: string, caller?: string) => void;
}

export interface NotifierServiceContract {
  notify: (message: string, level: NotifierLevel) => void;
  info: (message: string) => void;
  warn: (message: string) => void;
  error: (message: string) => void;
  success: (message: string) => void;
}

export interface ResizeManagerContract {
  initialize: () => void;
  register: (plugin: ResizePlugin) => void;
  runAll: () => void;
  unregister: (plugin: ResizePlugin) => void;
}

// ================================================== //
// ================================================== //
// ================================================== //

export interface StateManagerContract {
  addLayer(layer: VisualLayer): void;
  addLifecycleHook(hook: StateLifecycleHook): void;
  addTextElement(elem: TextElement): void;
  canRedoCanvas: () => boolean;
  canUndoCanvas: () => boolean;
  clearCanvasAll(): void;
  clearCanvasAnimation: () => void;
  getCanvas: () => CanvasState;
  getCanvasAspectRatio: () => number | undefined;
  getClient: () => ClientState;
  getState: () => State;
  moveLayer: (index: number, newIndex: number) => void;
  moveTextElement: (index: number, x: number, y: number) => void;
  removeLayer: (index: number) => void;
  resetCanvas: () => void;
  setCanvas: (width: number, height: number) => void;
  setCanvasAnimation: (anim: GifAnimation | null) => void;
  setCanvasAspectRatio: (aspect: number) => void;
  setCanvasImage: (imageDataUrl: string | undefined) => void;
  setClient: (viewportWidth: number, viewportHeight: number) => void;
  setSelectedLayerIndex: (index: number | null) => void;
  subscribeToCanvas: (fn: Subscriber<CanvasState>) => () => void;
  subscribeToClient: (fn: Subscriber<ClientState>) => () => void;
  redoCanvas: () => void;
  undoCanvas: () => void;
  updateLayer: (index: number, newLayer: VisualLayer) => void;
  updateTextElement: (index: number, newElem: TextElement) => void;
}

export interface CanvasStateServiceContract {
  addLayer(layer: VisualLayer): void;
  addTextElement: (elem: TextElement) => void;
  canRedo: () => boolean;
  canUndo: () => boolean;
  clearAll: () => void;
  clearAnimation: () => void;
  get: () => CanvasState;
  getAspectRatio: () => number | undefined;
  getLayers(): VisualLayer[];
  getSelectedLayerIndex(): number | null;
  moveLayer(index: number, newIndex: number): void;
  moveTextElement: (index: number, x: number, y: number) => void;
  redo: () => void;
  removeLayer(index: number): void;
  removeTextElement: (index: number) => void;
  reset: () => void;
  set: (width: number, height: number) => void;
  setAnimation: (anim: GifAnimation) => void;
  setAspectRatio: (aspect: number) => void;
  setCanvasImage: (imageDataUrl: string | undefined) => void;
  setSelectedLayerIndex(index: number | null): void;
  subscribe: (fn: Subscriber<CanvasState>) => () => void;
  undo: () => void;
  updateLayer(index: number, newLayer: VisualLayer): void;
  updateTextElement: (index: number, newElem: TextElement) => void;
}

export interface ClientStateServiceContract {
  get: () => ClientState;
  set: (viewportWidth: number, viewportHeight: number) => void;
  subscribe: (fn: Subscriber<ClientState>) => () => void;
}

// ================================================== //
// ================================================== //
// ================================================== //

export interface IStorageService {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T): Promise<void>;
  remove(key: string): Promise<void>;
  clear(): Promise<void>;
}

// ================================================== //
// ================================================== //
// ================================================== //

export interface RenderingEngineContract {
  addRedrawPlugin: (plugin: RedrawPlugin) => void;
  drawDevOverlay: () => void;
  render: (state?: CanvasState) => void;
  removeRedrawPlugin: (plugin: RedrawPlugin) => void;
  renderTo: (ctx: CanvasRenderingContext2D, state?: CanvasState) => void;
}
// File: frontend/src/app/types/generics.ts

export type Brand<T, B extends string> = T & { __brand: B };
// File: frontend/src/app/types/data.ts

import type { AssetClass } from './index.js';

export interface AssetData {
  exts: AssetExts;
  tags: AssetTags;
}

export interface AssetExts {
  supported: SupportedExts;
  unsupported: UnsupportedExts;
}

export type AssetManifest = {
  name: string;
  class: AssetClass;
  ext: string;
  type: string;
  src: string;
}[];

export type AssetTags = string[];

export interface BaseData {
  version: string;
}

export interface ConfigData {
  defaults: Defaults;
  paths: Paths;
  regex: Regex;
}

export interface Defaults {
  animation: {
    frameCount: number;
  };
  canvasWidth: number;
  canvasHeight: number;
  debounceWait: number;
  fileName: string;
  font: string;
  textAlignment: CanvasTextAlign;
  textBaseline: CanvasTextBaseline;
  textColor: string;
  textElement: {
    font: string;
    color: string;
    align: CanvasTextAlign;
    baseline: CanvasTextBaseline;
  };
}

export interface DomDivIds {
  assetBrowserDiv: string;
  canvasContainerDiv: string;
  canvasToolbarDiv: string;
}

export interface DomBtnIds {
  clearBtn: string;
  downloadBtn: string;
  toggleAssetBrowserBtn: string;
  uploadBtn: string;
}

export type DomClasses = Record<string, string>;

export interface DomData {
  classes: DomClasses;
  ids: DomIds;
}

export interface DomFormIds {
  textForm: string;
}

export type DomIds = DomBtnIds &
  DomDivIds &
  DomFormIds &
  DomInputIds & {
    canvas: string;
  };

export interface DomInputIds {
  imgUploadInput: string;
  textInput: string;
}

export interface ErrorMessages {
  unknownFatalError: string;
}

export interface Flags {
  devMode: boolean;
}

export interface Manifests {
  asset: AssetManifest;
}

export interface MessageData {
  errors: ErrorMessages;
}

export interface Paths {
  gifWorkerScript: '/assets/scripts/gif.worker.js';
}

export interface Regex {
  floatString: RegExp;
  hex: RegExp;
  integerString: RegExp;
  numberString: RegExp;
}

export type SupportedExt = 'gif' | 'jpeg' | 'jpg' | 'png' | 'webp';

export type SupportedExts = Readonly<SupportedExt[]>;

export type UnsupportedExt = 'svg';

export type UnsupportedExts = Readonly<UnsupportedExt[]>;

// ================================================== //

export interface Data extends BaseData {
  assets: AssetData;
  config: ConfigData;
  dom: DomData;
  flags: Flags;
  msgs: MessageData;
}
// File: frontend/src/app/types/css.ts/

export type TextUnit = 'em' | 'pt' | 'px' | 'rem';

export interface TextStyle {
  font: {
    align?: 'left' | 'center' | 'right' | 'justify';
    baseline?: 'middle' | 'top' | 'bottom';
    color?: string;
    family?: string;
    size?: {
      value: number;
      unit: TextUnit;
    };
    weight?: 'normal' | 'bold';
  };
}

export interface Styles {
  text: TextStyle[];
}
// File: frontend/src/app/types/layers.ts

import type {
  AnimationProps,
  OverlayAsset,
  SupportedAsset,
  TextElement
} from '../index.js';

export interface BaseVisualLayer {
  id: string;
  type: string;
  assetRef: SupportedAsset | null;
  opacity: number;
  visible: boolean;
  zIndex: number;
  position?: { x: number; y: number };
  rotation?: {
    speed: number;
    direction: 'clockwise' | 'counter-clockwise' | 'n/a';
    currentAngle: number;
  };
  scale?: { x: number; y: number };
}

export interface GifAnimation {
  frames: GifFrame[];
  isPlaying: () => boolean;
  pause: () => void;
  play: (ctx: CanvasRenderingContext2D, loop?: boolean) => void;
  stop: () => void;
}

export interface GifFrame {
  imageData: ImageData;
  delay: number; // in ms
}

export interface GifVisualLayer extends BaseVisualLayer {
  type: 'gif';
  animationProps?: AnimationProps;
  gifFrames: GifFrame[];
  currentFrame: number;
  frameElapsed: number;
}

export interface ImageVisualLayer extends BaseVisualLayer {
  type: 'image';
  element: HTMLImageElement;
}

export interface OverlayVisualLayer extends BaseVisualLayer {
  type: 'overlay';
  blendMode?: OverlayAsset['blendMode'];
  element: HTMLImageElement | HTMLCanvasElement;
}

export interface StickerVisualLayer extends BaseVisualLayer {
  type: 'sticker';
  element: HTMLImageElement | HTMLCanvasElement;
}

export interface TextVisualLayer extends BaseVisualLayer {
  type: 'text';
  textElements: TextElement[];
}

export interface VideoVisualLayer extends BaseVisualLayer {
  type: 'video';
  element: HTMLVideoElement;
}

export type VisualLayer =
  | ImageVisualLayer
  | GifVisualLayer
  | OverlayVisualLayer
  | StickerVisualLayer
  | TextVisualLayer
  | VideoVisualLayer;
// File: frontend/src/app/types/assets.ts

import { VisualLayer } from './index.js';

export interface AnimationGroup {
  id: string;
  layers: VisualLayer[];
  isPlaying: boolean;
  playbackRate: number;
}

export interface AnimationProps {
  frames: {
    count: number;
    rate: number; // fps
  };
  rotation?: {
    speed: 360; // degrees per second
    direction: 'clockwise' | 'counter-clockwise' | 'n/a';
  };
}

export type AssetClass = 'animation' | 'image' | 'text';

export type AssetManifestEntry =
  | BackgroundAsset
  | BorderAsset
  | FontAsset
  | GifAsset
  | ImageAsset
  | OverlayAsset
  | StickerAsset;

export interface BaseAsset {
  name: string;
  src: string /* path relative to assets/ */;
  size_kb: number;
  hash_sha256: string;
  class: string;
  extension: string;
  tags?: string[];
  credit?: string;
  license?: string;
}

export interface BackgroundAsset extends BaseAsset {
  tileable: boolean;
}

export interface BorderAsset extends BaseAsset {
  animated: boolean;
  width: number;
  shape: 'circle' | 'square' | 'rounded' | 'other';
}

export interface FontAsset extends BaseAsset {
  fontFamily: string;
  serif: boolean;
  style?: string;
  weight?: number | string;
}

export interface GifAsset extends BaseAsset {
  animation?: AnimationProps;
}

export interface ImageAsset extends BaseAsset {}

export interface OverlayAsset extends BaseAsset {
  blendMode?:
    | 'normal'
    | 'multiply'
    | 'screen'
    | 'overlay'
    | 'darken'
    | 'lighten'
    | 'color-dodge'
    | 'color-burn'
    | 'hard-light'
    | 'soft-light'
    | 'difference'
    | 'exclusion';
}

export interface StickerAsset extends BaseAsset {}

export type SupportedAsset =
  | ImageAsset
  | GifAsset
  | OverlayAsset
  | StickerAsset;
// File: frontend/src/app/types/app/index.ts

export type {
  AnimationGroup,
  AnimationProps,
  AssetClass,
  AssetManifestEntry,
  BaseAsset,
  BackgroundAsset,
  BorderAsset,
  FontAsset,
  GifAsset,
  ImageAsset,
  OverlayAsset,
  StickerAsset,
  SupportedAsset
} from './assets.js';
export type {
  Cache,
  CanvasResizeOptions,
  ErrorHandlerOptions,
  ListenerRegistration,
  NotifierLevel,
  Plugin,
  RedrawPlugin,
  ResizePlugin,
  Subscriber,
  TextElement,
  UIInitializer
} from './core.js';
export type { CanvasLifecycleEvent, StateLifecycleHook } from './engine.js';
export type {
  BaseVisualLayer,
  GifAnimation,
  GifFrame,
  GifVisualLayer,
  ImageVisualLayer,
  OverlayVisualLayer,
  StickerVisualLayer,
  TextVisualLayer,
  VideoVisualLayer,
  VisualLayer
} from './layers.js';
export type { CanvasState, ClientState, State } from './state.js';
// File: frontend/src/app/types/app/state.ts

import type { VisualLayer } from './layers.js';

export type CanvasState = {
  width: number;
  height: number;
  layers: VisualLayer[];
  selectedLayerIndex: number | null;
  aspectRatio?: number | undefined;
};

export interface ClientState {
  viewportWidth: number;
  viewportHeight: number;
}

export interface State {
  version: string;
  canvas: CanvasState;
  client: ClientState;
}
// File: frontend/src/application/types/app/core.ts

import type { Core } from '../index.js';

export interface Cache {
  bgImg: HTMLImageElement | null;
}

export interface CanvasResizeOptions {
  canvas: HTMLCanvasElement;
  container: HTMLElement;
  preserveAspectRatio?: boolean;
}

export interface ErrorHandlerOptions {
  context?: Record<string, unknown> | string;
  fallback?: unknown;
  userMessage?: string;
}

export type ListenerRegistration = (core: Core) => void | (() => void);

export type NotifierLevel = 'info' | 'warn' | 'error' | 'success';

export interface Plugin {
  id: string;
  register: (core: Core) => void | Promise<void>;
}

export type RedrawPlugin = (ctx: CanvasRenderingContext2D, core: Core) => void;

export type ResizePlugin = () => void;

export type Subscriber<T> = (state: T) => void;

export interface TextElement {
  text: string;
  x: number;
  y: number;
  align: CanvasTextAlign;
  baseline: CanvasTextBaseline;
  color: string;
  font: string;
  fontFamily?: string;
  fontSize: number;
  fontWeight?: string;
  rotation?: number;
  scale?: number;
}

export type UIInitializer = (core: Core) => void | Promise<void>;
// File: frontend/src/app/types/app/cache.ts

export interface Cache {
  bgImg: HTMLImageElement | null;
}
// File: frontend/src/app/types/app/engine.ts

import type { CanvasState } from '../index.js';

export type CanvasLifecycleEvent =
  | 'addLayer'
  | 'removeLayer'
  | 'undo'
  | 'redo'
  | 'clear';

export type StateLifecycleHook = (
  event: CanvasLifecycleEvent,
  state: CanvasState
) => void;
// File: frontend/src/app/main.ts

import('./sys/events/dom.js').then(({ onDOMContentLoaded }) => {
  onDOMContentLoaded(async () => {
    try {
      const { launchApp } = await import('./sys/launch.js');
      const {
        core: {
          data: {
            dom: { ids }
          }
        }
      } = await launchApp();

      const canvas = document.getElementById(
        ids.canvas
      ) as HTMLCanvasElement | null;

      if (!canvas) throw new Error('Canvas element not found in DOM!');

      const ctx = canvas.getContext('2d');
      if (!ctx) throw new Error('2D context not available for canvas!');
    } catch (error) {
      console.error(
        `An unhandled error occurred during application startup:`,
        error instanceof Error ? error.message : error
      );
      throw new Error(`Startup failed.`);
    }
  });
});

export {};
// File: frontend/src/app/sys/bootstrap.ts

import type { Core } from '../types/index.js';

async function setGlobalErrorHandlers(core: Core): Promise<void> {
  const {
    services: { log }
  } = core;

  log.info(`Registering global error handlers`);

  try {
    window.onerror = function (message, source, lineno, colno, error) {
      console.log(
        `Unhandled error: ${message} at ${source}:${lineno}:${colno}`
      );
      if (error && error.stack) {
        console.log(`Stack trace:\n${error.stack}`);
      }
      return false;
    };
    window.addEventListener('unhandledrejection', event => {
      console.log(`Unhandled promise rejection: ${event.reason}`);
    });
  } catch (error) {
    log.error(
      `Failed to register global error handlers:`,
      error instanceof Error ? error.message : String(error)
    );
    throw new Error(`Global error handler registration failed.`);
  }
}

// ================================================== //

export async function bootstrap(core: Core): Promise<void> {
  await setGlobalErrorHandlers(core);
}
// File: frontend/src/app/sys/launch.ts

import type { Core } from '../types/index.js';
import { RenderingEngine } from '../features/engine/RenderingEngine.js';

export async function launchApp(): Promise<{
  core: Core;
  renderingEngine: RenderingEngine;
}> {
  try {
    console.log(`Launching application...`);

    // 1. Load Static Data
    console.log(`Loading static Data object...`);
    const { initializeData } = await import('./initialize.js');
    const data = await initializeData();
    console.log(
      `Successfully loaded static Data object: ${JSON.stringify(data, null, 2)}`
    );

    // 2. Initialize App Core
    console.log(`Initializing App Core...`);
    const { initializeCore } = await import('./initialize.js');
    const core = await initializeCore();
    const {
      services: { log }
    } = core;
    log.info(
      `Successfully initialized the Application Core.`,
      JSON.stringify(core, null, 2)
    );

    // 3. Global One-Off Setup (error handlers, etc.)
    log.info(`Executing bootstrap processes...`);
    const { bootstrap } = await import('./bootstrap.js');
    await bootstrap(core);
    log.info(`Bootstrap processes completed successfully.`);

    // 4. Register Event Listeners
    log.info(`Registering event listeners...`);
    const { eventListeners, registerEventListeners } = await import(
      './registries/events.js'
    );
    registerEventListeners(eventListeners, core);
    log.info(`Event listeners registered successfully.`);

    // 5. Register Plugins
    log.info(`Registering plugins...`);
    const { plugins } = await import('./registries/plugins.js');
    for (const plugin of plugins) await plugin.register(core);
    log.info(`Plugins registered successfully.`);

    // 6. Initialize User Interface
    log.info(`Initializing User Interface...`);
    const { initializeUI } = await import('./initialize.js');
    await initializeUI(core);
    log.info(`User Interface initialized successfully.`);

    // 7. Initialize Rendering Engine
    log.info(`Initializing Rendering Engine...`);
    const { initializeRenderingEngine } = await import('./initialize.js');
    const ctx = document.querySelector('canvas')?.getContext('2d');
    if (!ctx) {
      throw new Error(`Failed to get 2D context from canvas element.`);
    }
    const renderingEngine = await initializeRenderingEngine(ctx, core);

    // 8. Initialise Asset Browser Rendering SubEngine
    log.info(`Initializing Asset Browser Rendering SubEngine...`);
    const { renderAssetBrowser } = await import(
      '../features/engine/asset_browser.js'
    );
    await renderAssetBrowser(core).then(() =>
      log.info(`Asset Browser Rendering SubEngine initialized successfully.`)
    );

    return {
      core,
      renderingEngine
    };
  } catch (error) {
    console.error(
      `An unknown error occurred during application startup:`,
      error
    );
    throw new Error(`Application startup failed.`);
  }
}
// File: frontend/src/app/sys/initialize.ts

import type {
  Core,
  Data,
  Helpers,
  Services,
  Utilities
} from '../types/index.js';
import { RenderingEngine } from '../features/engine/RenderingEngine.js';

export async function initializeData(): Promise<Required<Data>> {
  console.log(`Initializing Data object...`);

  try {
    const { data } = await import('../data/index.js');

    return data;
  } catch (error) {
    console.error(`Failed to initialize Data:`, error);
    throw new Error(`Data initialization failed`);
  }
}

async function initializeHelpers(): Promise<Required<Helpers>> {
  console.log(`Initializing Helpers object...`);

  try {
    const { helpersFactory } = await import('../core/factories/helpers.js');

    const helpers: Helpers = await helpersFactory();

    return helpers;
  } catch (error) {
    console.error(`Failed to initialize Helpers:`, error);
    throw new Error(`Helpers initialization failed`);
  }
}

async function initializeServices(
  data: Data,
  helpers: Helpers
): Promise<Required<Services>> {
  console.log(`Initializing Services object...`);

  try {
    const { serviceFactory } = await import('../core/factories/services.js');

    const services: Services = await serviceFactory(data, helpers);

    return services;
  } catch (error) {
    console.error(`Failed to initialize Services:`, error);
    throw new Error(`Services initialization failed`);
  }
}

async function initializeUtilities(
  services: Services
): Promise<Required<Utilities>> {
  console.log(`Initializing Utilities object...`);

  return await services.errors.handleAsync(async () => {
    const { utilitiesFactory } = await import('../core/factories/utilities.js');
    const utilities: Utilities = await utilitiesFactory(services);

    return utilities;
  }, `Utilities initialization failed.`);
}

// ================================================== //

export async function initializeCore(): Promise<Core> {
  console.log(`Starting dependency initialization...`);

  let core = {} as Core;

  const data = await initializeData();
  core.data = data;

  const helpers = await initializeHelpers();
  core.helpers = helpers;

  const services = await initializeServices(data, helpers);
  core.services = services;

  const utils = await initializeUtilities(services);
  core.utils = utils;

  const log = services.log;
  log.info(`All dependencies initialized successfully.`);

  return core;
}

export async function initializeRenderingEngine(
  ctx: CanvasRenderingContext2D,
  core: Core
): Promise<RenderingEngine> {
  const {
    services: { errors, log }
  } = core;

  return errors.handleAsync(async () => {
    log.info('Initializing the Rendering Engine...');
    const renderingEngine = RenderingEngine.getInstance(ctx, core);
    return renderingEngine;
  }, `Rendering Engine initialization failed.`);
}

export async function initializeUI(core: Core): Promise<RenderingEngine> {
  const {
    data: {
      dom: { ids }
    },
    services
  } = core;
  const { errors } = services;

  return errors.handleAsync(async () => {
    const canvas = document.getElementById(
      ids.canvas
    ) as HTMLCanvasElement | null;
    if (!canvas) throw new Error(`Canvas element not found in DOM!`);
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error(`2D context not available for canvas!`);
    const container = document.getElementById(ids.canvasContainerDiv);
    if (!container) throw new Error(`Canvas container not found in DOM!`);

    const canvasRefs = { canvas, ctx };
    const renderingEngine = await initializeRenderingEngine(ctx, core);

    const { io } = await import('../features/engine/io.js');
    const { overlayFns: overlay } = await import(
      '../features/engine/overlays.js'
    );
    const { initializeCanvasUI } = await import('../features/engine/start.js');

    await initializeCanvasUI(io, overlay, core, renderingEngine);

    renderingEngine.autoResize({
      canvas,
      container,
      preserveAspectRatio: true
    });

    window.addEventListener('resize', () => {
      errors.handleSync(() => {
        renderingEngine.resizeCanvasToParent();
        renderingEngine.clearCanvas(canvasRefs.ctx);
        renderingEngine.drawBoundary(canvasRefs.ctx);
      }, 'Canvas resize/redraw failed');
    });

    return renderingEngine;
  }, `UI initialization failed.`);
}
// File: frontend/src/app/sys/registries/events.ts

import type { Core, ListenerRegistration } from '../../types/index.js';

export const eventListeners: ListenerRegistration[] = [
  (core: Core) => {
    const {
      services: { errors, log, stateManager }
    } = core;
    errors.handleSync(() => {
      log.info(
        'Registering global event listeners...',
        'registries > events > eventListeners'
      );

      window.addEventListener('resize', () => {
        // TODO: resize handler logic here
      });

      window.addEventListener('keydown', (event: KeyboardEvent) => {
        if (
          event.key === 'Delete' &&
          stateManager.getCanvas().selectedLayerIndex !== null
        ) {
          const idx = stateManager.getCanvas().selectedLayerIndex!;
          stateManager.removeTextElement(idx);
          stateManager.getCanvas().selectedLayerIndex = null;
          log.info(
            `Deleted text element at index: ${idx}`,
            'event:keydown:Delete'
          );
        }
      });
    }, 'Unhandled error during event listener registration.');
  }
];

// ================================================== //

export function registerEventListeners(
  listeners: ListenerRegistration[],
  core: Core
): void {
  const {
    data: { msgs },
    services: { errors }
  } = core;
  const errorMsgs = msgs.errors;

  errors.handleAsync(
    async () => {
      listeners.forEach(listener => listener(core));
    },
    'An unknown error occurred while registering event listeners.',
    {
      context: 'application startup',
      fallback: 'n/a',
      userMessage: errorMsgs.unknownFatalError
    }
  );
}
// File: frontend/src/app/sys/registries/plugins.ts

import type { Plugin } from '../../types/index.js';

export const plugins: Plugin[] = [];

// ================================================== //

export function registerPlugin(_plugin: Plugin): void {}
// File: frontend/src/app/sys/registries/ui.ts

import type { UIInitializer } from '../../types/index.js';

// ================================================== //

export const uiInitializers: UIInitializer[] = [];
// File: frontend/src/app/sys/events/dom.ts

// ================================================== //
// ================================================== //

export function onDOMContentLoaded(cb: () => void): void {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', cb);
  } else {
    cb();
  }
}

// ================================================== //

export function onResize(cb: () => void): void {
  window.addEventListener('resize', cb);
}
// File: frontend/src/app/data/index.ts

import type { Data } from '../types/index.js';
import { assetsData } from './assets.js';
import { baseData } from './base.js';
import { configData } from './config.js';
import { domData } from './dom.js';
import { flags } from './flags.js';
import { messageData } from './messages.js';

export const data: Data = {
  ...baseData,
  assets: assetsData,
  config: configData,
  dom: domData,
  flags: flags,
  msgs: messageData
} as const;
// File: frontend/src/app/core/data/flags.ts

import type { Flags } from '../types/index.js';

export const flags: Flags = {
  devMode: true
} as const;
// File: frontend/src/app/core/data/config.ts

import type { ConfigData, Defaults, Paths, Regex } from '../types/index.js';

// ================================================== //

const defaultCanvasWidth: number = 800;
const defaultCanvasHeight: number = 600;
const defaultDebounceWait: number = 100;
const defaultFileName: string = 'something_broke';

const defaultAnimationFrameCount: number = 60;
const defaultFont: string = 'Arial';
const defaultTextColor = '#000000';
const defaultTextAlignment: CanvasTextAlign = 'center';
const defaultTextBaseline: CanvasTextBaseline = 'middle';

const defaultTextElement = {
  font: defaultFont,
  color: defaultTextColor,
  align: defaultTextAlignment,
  baseline: defaultTextBaseline
};

const defaults: Defaults = {
  animation: {
    frameCount: defaultAnimationFrameCount
  },
  canvasWidth: defaultCanvasWidth,
  canvasHeight: defaultCanvasHeight,
  debounceWait: defaultDebounceWait,
  fileName: defaultFileName,
  font: defaultFont,
  textAlignment: defaultTextAlignment,
  textBaseline: defaultTextBaseline,
  textColor: defaultTextColor,
  textElement: defaultTextElement
};

// ================================================== //

const paths: Paths = {
  gifWorkerScript: '/assets/scripts/gif.worker.js'
} as const;

// ================================================== //

const floatString: RegExp = /^[-+]?\d*\.\d+(e[-+]?\d+)?$/i;
const hex: RegExp = /^#(?:[0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/;
const integerString: RegExp = /^[-+]?\d+$/i;
const numberString: RegExp = /^[-+]?\d*\.?\d+(e[-+]?\d+)?$/i;

export const regex: Regex = {
  floatString,
  hex,
  integerString,
  numberString
} as const;

// =================================================== //

export const configData: ConfigData = {
  defaults,
  paths,
  regex
} as const;
// File: frontend/src/app/config/core/messages.ts

import type { ErrorMessages, MessageData } from '../types/index.js';

const unknownFatalError =
  'An unknown fatal error has occurred. Please refresh the page and try again. If the problem persists, please contact support.';

const errorMessages: ErrorMessages = {
  unknownFatalError
};

// ================================================== //

export const messageData: MessageData = {
  errors: errorMessages
} as const;
// File: frontend/src/app/core/data/dom.ts

import type {
  DomBtnIds,
  DomDivIds,
  DomClasses,
  DomData,
  DomFormIds,
  DomIds,
  DomInputIds
} from '../types/index.js';

// ================================================== //

const assetThumb = 'asset-thumbnail';
const fontSelector = 'font-selector';
const textEditOverlay = 'text-edit-overlay';
const textColorPicker = 'text-color-picker';
const textSizeInput = 'text-size-input';

const classes: DomClasses = {
  assetThumb,
  fontSelector,
  textColorPicker,
  textEditOverlay,
  textSizeInput
} as const;

// ================================================== //

const assetBrowserDiv = 'asset-browser';
const canvas = 'main-canvas';
const canvasContainerDiv = 'canvas-container';
const canvasToolbarDiv = 'canvas-toolbar';
const clearBtn = 'clear-btn';
const downloadBtn = 'download-btn';
const imgUploadInput = 'img-upload-input';
const textInput = 'text-input';
const textForm = 'text-form';
const toggleAssetBrowserBtn = 'toggle-asset-browser-btn';
const uploadBtn = 'upload-btn';

const btns: DomBtnIds = {
  clearBtn,
  downloadBtn,
  toggleAssetBrowserBtn,
  uploadBtn
} as const;

const divs: DomDivIds = {
  assetBrowserDiv,
  canvasContainerDiv: canvasContainerDiv,
  canvasToolbarDiv: canvasToolbarDiv
} as const;

const forms: DomFormIds = {
  textForm
} as const;

const inputs: DomInputIds = {
  imgUploadInput,
  textInput
} as const;

const domIDs: DomIds = {
  canvas,
  ...btns,
  ...divs,
  ...forms,
  ...inputs
} as const;

// ================================================== //

export const domData: DomData = {
  classes,
  ids: domIDs
} as const;
// File: frontend/src/app/core/data/assets.ts

import type {
  AssetData,
  AssetExts,
  AssetTags,
  SupportedExt,
  SupportedExts,
  UnsupportedExt,
  UnsupportedExts
} from '../types/index.js';

const supportedExts: SupportedExts = [
  'gif',
  'jpeg',
  'jpg',
  'png',
  'webp'
] as readonly SupportedExt[];

const unsupportedExts: UnsupportedExts = ['svg'] as readonly UnsupportedExt[];

const exts: AssetExts = {
  supported: supportedExts,
  unsupported: unsupportedExts
} as const;

export const tags: AssetTags = ['animation', 'custom', 'rotate'] as const;

// ================================================== //

export const assetsData: AssetData = {
  exts,
  tags
} as const;
// File: frontend/src/app/core/data/base.ts

import type { BaseData } from '../types/index.js';

const version = '0.0.1' as const;

export const baseData: BaseData = {
  version
} as const;
// File: frontend/src/app/features/engine/RenderingEngine.ts

import type {
  CanvasResizeOptions,
  CanvasState,
  Core,
  ImageVisualLayer,
  RedrawPlugin,
  RenderingEngineContract,
  TextVisualLayer,
  VisualLayer
} from '../../types/index.js';

// ====================================================== //
// ====================================================== //

export class RenderingEngine implements RenderingEngineContract {
  static #instance: RenderingEngine | null = null;

  #data: Core['data'];
  #devMode: Core['data']['flags']['devMode'];
  #redrawPlugins: RedrawPlugin[] = [];

  #ctx: CanvasRenderingContext2D | null = null;

  #core: Core;
  #errors: Core['services']['errors'];
  #helpers: Core['helpers'];
  #log: Core['services']['log'];
  #stateManager: Core['services']['stateManager'];
  #utils: Core['utils'];

  // ==================================================== //

  private constructor(ctx: CanvasRenderingContext2D, core: Core) {
    const {
      data,
      helpers,
      services: { errors, log, stateManager },
      utils
    } = core;

    this.#ctx = ctx;

    this.#core = core;

    this.#data = data;
    this.#helpers = helpers;
    this.#utils = utils;

    this.#devMode = data.flags.devMode;
    this.#errors = errors;
    this.#log = log;
    this.#stateManager = stateManager;

    this.#stateManager.subscribeToCanvas(() => {
      this.render();
    });
  }

  // ==================================================== //

  static getInstance(
    ctx: CanvasRenderingContext2D,
    core: Core
  ): RenderingEngine {
    const { errors, log } = core.services;
    return errors.handleSync(() => {
      log.info(`RENDERING_ENGINE: calling getInstance()...`);

      if (!RenderingEngine.#instance) {
        log.info(
          `RENDERING_ENGINE: No existing instance found. Creating new instance.`
        );
        RenderingEngine.#instance = new RenderingEngine(ctx, core);
      }

      return RenderingEngine.#instance;
    }, 'RENDERING_ENGINE: Failed to get instance.');
  }

  // ==================================================== //

  render(state: CanvasState = this.#stateManager.getCanvas()): void {
    return this.#errors.handleSync(() => {
      // 1. clear the canvas
      this.clearCanvas(this.#ctx!);

      // 2. draw dev overlays
      if (this.#devMode) this.drawDevOverlay();

      // 3. draw main boundary
      this.drawBoundary(this.#ctx!);

      // 4. draw all layers (z-index, blend mode, etc.)
      if (state.layers.length > 0) {
        this.#utils.canvas.drawVisualLayersToContext(
          this.#ctx!,
          state.layers,
          this.#helpers
        );
      }
      // 5. draw text and selection overlays
      this.#drawTextAndSelection(
        this.#ctx!,
        state.layers,
        state.selectedLayerIndex
      );

      // 6. run redraw plugins
      for (const plugin of this.#redrawPlugins) {
        plugin(this.#ctx!, this.#core);
      }
    }, 'RENDERING_ENGINE: Failed to render canvas.');
  }

  // ==================================================== //

  addRedrawPlugin(plugin: RedrawPlugin): void {
    return this.#errors.handleSync(() => {
      this.#redrawPlugins.push(plugin);
    }, 'RENDERING_ENGINE: Failed to add redraw plugin.');
  }

  attachImageOnLoadHandler(layer: ImageVisualLayer): void {
    if (layer.element && !layer.element.complete) {
      this.render();
    }
  }

  autoResize({
    canvas,
    container,
    preserveAspectRatio = true
  }: CanvasResizeOptions): () => void {
    return this.#errors.handleSync(() => {
      const resize = () => {
        const rect = container.getBoundingClientRect();

        if (preserveAspectRatio) {
          const aspect = canvas.width / canvas.height || 4 / 3;
          let width = rect.width;
          let height = rect.width / aspect;

          if (height > rect.height) {
            height = rect.height;
            width = rect.height * aspect;
          }

          canvas.style.width = `${width}px`;
          canvas.style.height = `${height}px`;
        } else {
          canvas.style.width = `${rect.width}px`;
          canvas.style.height = `${rect.height}px`;
        }
      };

      resize(); // initial resize call

      window.addEventListener('resize', resize);

      return () => window.removeEventListener('resize', resize);
    }, 'Unhandled canvas auto-resize error.');
  }

  clearCanvas(ctx: CanvasRenderingContext2D): void {
    return this.#errors.handleSync(() => {
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    }, 'RENDERING_ENGINE: Unhandled canvas clear error.');
  }

  drawBoundary(ctx: CanvasRenderingContext2D): void {
    return this.#errors.handleSync(() => {
      ctx.save();
      ctx.lineWidth = 8;

