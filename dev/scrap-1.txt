viihna@sharkie:~/Projects/graphix/frontend/scripts$ ./print_ts.sh
// File: frontend/src/app/core/utils/dom.ts

import { DomUtils } from '../../types/index.js';

// ================================================== //
// ================================================== //

export const domUtilityFactory = (): DomUtils => ({
  getCssVar(name: string): string {
    return getComputedStyle(document.documentElement)
      .getPropertyValue(name)
      .trim();
  }
});
// File: frontend/src/app/core/utils/data.ts

import type { DataUtils } from '../../types/index.js';

export const dataUtilityFactory = (): DataUtils => ({
  detectFileType(file: File): Promise<string | undefined> {
    const reader = new FileReader();

    return new Promise((resolve, reject) => {
      reader.onload = () => {
        const bytes = new Uint8Array(reader.result as ArrayBuffer);
        if (bytes[0] === 0x89 && bytes[1] === 0x50) return resolve('png');
        if (bytes[0] === 0xff && bytes[1] === 0xd8) return resolve('jpeg');
        if (bytes[0] === 0x47 && bytes[1] === 0x49) return resolve('gif');
        if (
          bytes[0] === 0x52 &&
          bytes[1] === 0x49 &&
          bytes[8] === 0x57 &&
          bytes[9] === 0x45
        )
          return resolve('webp');
        resolve(undefined);
      };
      reader.onerror = reject;
      reader.readAsArrayBuffer(file.slice(0, 16));
    });
  }
});
// File: frontend/src/app/core/utils/math.ts

import type { MathUtils } from '../../types/index.js';

export const mathUtilityFactory = (): MathUtils => ({
  modulo(x: number, n: number): number {
    return ((x % n) + n) % n;
  },

  roundToStep(x: number, step: number): number {
    return Math.round(x / step) * step;
  },

  toDegrees(rad: number): number {
    return rad * (180 / Math.PI);
  },

  toRadians(deg: number): number {
    return deg * (Math.PI / 180);
  }
});
// File: frontend/src/app/core/utils/canvas.ts

import type { Helpers, CanvasUtils, VisualLayer } from '../../types/index.js';

export const canvasUtilityFactory = (): CanvasUtils => ({
  drawVisualLayersToContext(
    ctx: CanvasRenderingContext2D,
    layers: VisualLayer[],
    helpers: Helpers
  ): void {
    layers
      .slice()
      .sort((a, b) => a.zIndex - b.zIndex)
      .forEach(layer => {
        if (!layer.visible) return;

        ctx.save();

        // default blend mode
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = layer.opacity;

        // apply transform
        const x = layer.position?.x ?? 0;
        const y = layer.position?.y ?? 0;
        const scaleX = layer.scale?.x ?? 1;
        const scaleY = layer.scale?.y ?? 1;
        const rotation = layer.rotation?.currentAngle ?? 0;

        ctx.translate(x, y);
        ctx.rotate((rotation * Math.PI) / 180);
        ctx.scale(scaleX, scaleY);

        switch (layer.type) {
          case 'gif': {
            const frame = layer.gifFrames[layer.currentFrame];
            if (frame) {
              ctx.putImageData(frame.imageData, 0, 0);
            }
            break;
          }
          case 'image': {
            if (
              layer.element &&
              layer.element.complete &&
              layer.element.naturalWidth > 0
            ) {
              ctx.drawImage(layer.element, 0, 0);
            }
            break;
          }

          case 'overlay': {
            ctx.globalCompositeOperation = helpers.canvas.mapBlendMode(
              layer.blendMode
            );
            ctx.drawImage(layer.element, 0, 0);
            break;
          }

          case 'sticker': {
            ctx.drawImage(layer.element, 0, 0);
            break;
          }

          case 'video': {
            ctx.drawImage(layer.element, 0, 0);
            break;
          }

          case 'text': {
            // no draw here â€” text layers are drawn in drawTextAndSelection()
            break;
          }
        }

        ctx.restore();
      });

    ctx.globalAlpha = 1.0;
    ctx.globalCompositeOperation = 'source-over';
  }
});
// File: frontend/src/app/core/helpers/math.ts

import { MathHelpers } from '../../types/index.js';

export const mathHelpersFactory = (): MathHelpers => ({
  weightedRandom(min: number, max: number, weight: number): number {
    const t = Math.pow(Math.random(), weight);
    return min + t * (max - min);
  }
});
// File: frontend/src/app/core/helpers/app.ts

import { Helpers } from '../../types/index.js';

export const appHelpersFactory = (): Helpers['app'] => ({
  noop(): void {}
});
// File: frontend/src/app/core/helpers/data.ts

import type { DataHelpers } from '../../types/index.js';

export const dataHelperFactory = async (): Promise<DataHelpers> => ({
  clone<T>(data: T): T {
    return structuredClone(data);
  },

  getFileSizeInKB(file: File | Blob): number {
    return Math.round(file.size / 1024);
  },

  async getFileSHA256(file: File | Blob): Promise<string> {
    const buf = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', buf);
    const hashArray = Array.from(new Uint8Array(hashBuffer));

    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }
});
// File: frontend/src/app/cpre/helpers/time.ts

import type { Data, Helpers } from '../../types/index.js';

const { data } = await import('../../data/index.js');
const defaultDebounceWait: Data['config']['defaults']['debounceWait'] =
  data.config.defaults.debounceWait;

// ================================================== //

export const timeHelpersFactory = (): Helpers['time'] => ({
  debounce<T extends (...args: Record<string, unknown>[]) => void>(
    fn: T,
    wait?: number
  ): (...args: Parameters<T>) => void {
    let timeout: ReturnType<typeof setTimeout> | null = null;

    if (!wait) wait = defaultDebounceWait;

    return function (...args: Parameters<T>) {
      if (timeout) clearTimeout(timeout);

      timeout = setTimeout(() => fn(...args), wait);
    };
  }
});
// File: frontend/src/app/core/helpers/canvas.ts

import type { CanvasHelpers, TextElement } from '../../types/index.js';

// ================================================== //

export const canvasHelpersFactory = (): CanvasHelpers => {
  return {
    get2DContext(canvas: HTMLCanvasElement): CanvasRenderingContext2D {
      const ctx = canvas.getContext('2d');
      if (!ctx) throw new Error('2D canvas context is not available!');

      return ctx;
    },

    getMousePosition(
      canvas: HTMLCanvasElement,
      evt: MouseEvent
    ): {
      x: number;
      y: number;
    } {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      return {
        x: (evt.clientX - rect.left) * scaleX,
        y: (evt.clientY - rect.top) * scaleY
      };
    },

    isOverResizeHandle(
      mouse: { x: number; y: number },
      elem: TextElement,
      ctx: CanvasRenderingContext2D
    ): boolean {
      const fontSize = elem.fontSize ?? 32;
      const fontWeight = elem.fontWeight ?? 'bold';
      const fontFamily = elem.fontFamily ?? 'sans-serif';
      ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;

      const width = ctx.measureText(elem.text).width;
      const height = fontSize;

      const handleSize = 10;
      const handleX = elem.x + width / 2 - handleSize / 2;
      const handleY = elem.y + height / 2 - handleSize / 2;

      return (
        mouse.x >= handleX &&
        mouse.x <= handleX + handleSize &&
        mouse.y >= handleY &&
        mouse.y <= handleY + handleSize
      );
    },

    isPointInText(
      pt: { x: number; y: number },
      elem: TextElement,
      ctx: CanvasRenderingContext2D
    ): boolean {
      ctx.save();

      const fontSize = elem.fontSize ?? 32;
      const fontWeight = elem.fontWeight ?? 'bold';
      const fontFamily = elem.fontFamily ?? 'sans-serif';
      ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;

      const width = ctx.measureText(elem.text).width;
      const height = fontSize;
      ctx.restore();

      return (
        pt.x >= elem.x - width / 2 &&
        pt.x <= elem.x + width / 2 &&
        pt.y >= elem.y - height / 2 &&
        pt.y <= elem.y + height / 2
      );
    },

    mapBlendMode(blendMode?: string): GlobalCompositeOperation {
      if (!blendMode || blendMode === 'normal') {
        return 'source-over';
      }

      return blendMode as GlobalCompositeOperation;
    }
  };
};
// File: frontend/src/app/core/factories/services.ts

import type { Data, Helpers, Services } from '../../types/index.js';
import {
  AnimationGroupManager,
  CacheManager,
  ErrorHandler,
  Logger,
  ResizeManager,
  StateManager,
  StorageManager
} from '../services/index.js';

// ================================================== //

export async function serviceFactory(
  data: Data,
  helpers: Helpers
): Promise<Required<Services>> {
  console.log(`Starting service factory...`);
  const services = {} as Services;

  console.log(`Initializing Logger, ErrorHandler, and StateManager services`);

  services.log = Logger.getInstance(helpers);
  services.errors = ErrorHandler.getInstance(services.log);
  services.storageManager = await StorageManager.getInstance();
  services.stateManager = StateManager.getInstance(
    data,
    services.errors,
    services.log
  );
  services.cache = CacheManager.getInstance(services.errors, services.log);
  services.resizeManager = ResizeManager.getInstance(
    services.errors,
    services.log
  );
  services.animationGroupManager = AnimationGroupManager.getInstance();

  if (!services.log || !services.errors) {
    throw new Error(`Logger and/or ErrorHandler failed to initialize.`);
  }

  return services;
}
// File: frontend/src/app/core/factories/helpers.ts

import type { Helpers } from '../../types/index.js';

// ================================================== //

export async function helpersFactory(): Promise<Required<Helpers>> {
  console.log(`Creating 'Helpers' object`);

  const helpers = {} as Helpers;

  const [
    { appHelpersFactory },
    { canvasHelpersFactory },
    { dataHelperFactory },
    { mathHelpersFactory },
    { timeHelpersFactory }
  ] = await Promise.all([
    import('../helpers/app.js'),
    import('../helpers/canvas.js'),
    import('../helpers/data.js'),
    import('../helpers/math.js'),
    import('../helpers/time.js')
  ]);

  helpers.app = appHelpersFactory();
  helpers.canvas = canvasHelpersFactory();
  helpers.data = await dataHelperFactory();
  helpers.math = mathHelpersFactory();
  helpers.time = timeHelpersFactory();

  console.log(`Helpers object has been successfully created`);

  return helpers;
}
// File: frontend/src/app/core/factories/utilities.ts

import type {
  CanvasUtils,
  DataUtils,
  DomUtils,
  MathUtils,
  Services,
  Utilities
} from '../../types/index.js';

export async function utilitiesFactory(
  services: Services
): Promise<Required<Utilities>> {
  const { errors, log } = services;

  return errors.handleAsync(async () => {
    log.info(`Creating 'Utilities' object.`);

    const utils = {} as Utilities;
    const { canvasUtilityFactory } = await import('../utils/canvas.js');
    const { dataUtilityFactory } = await import('../utils/data.js');
    const { domUtilityFactory } = await import('../utils/dom.js');
    const { mathUtilityFactory } = await import('../utils/math.js');

    const canvasUtils: CanvasUtils = canvasUtilityFactory();
    const dataUtils: DataUtils = dataUtilityFactory();
    const domUtils: DomUtils = domUtilityFactory();
    const mathUtils: MathUtils = mathUtilityFactory();

    utils.canvas = canvasUtils;
    utils.data = dataUtils;
    utils.dom = domUtils;
    utils.math = mathUtils;

    log.info(`'Utilities' object has been successfully created.`);

    return utils;
  }, `Utilities initialization failed.`);
}
// File: frontend/src/app/core/services/ErrorHandler.ts

import {
  ErrorHandlerServiceContract,
  ErrorHandlerOptions
} from '../../types/index.js';
import { errorClasses, ErrorClasses } from '../config/errors.js';
import { Logger } from './Logger.js';

// ================================================== //
// ================================================== //

export class ErrorHandler implements ErrorHandlerServiceContract {
  static #instance: ErrorHandler | null = null;
  #errorClasses: ErrorClasses = errorClasses;
  #logger: Logger;

  private constructor(logger: Logger) {
    try {
      this.#logger = logger;
    } catch (error) {
      throw new Error(`${error instanceof Error ? error.message : error}`);
    }
  }

  static getInstance(logger: Logger): ErrorHandler {
    try {
      if (!ErrorHandler.#instance) {
        console.debug(
          `No ErrorHandler instance exists yet. Creating new instance.`
        );
        ErrorHandler.#instance = new ErrorHandler(logger);
      }

      console.debug(`Returning ErrorHandler instance.`);

      return ErrorHandler.#instance;
    } catch (error) {
      throw new Error(`${error instanceof Error ? error.message : error}`);
    }
  }

  handleAndReturn<T>(
    action: () => T | Promise<T>,
    errorMessage: string,
    options: ErrorHandlerOptions = {}
  ): T | Promise<T> {
    try {
      const result = action();

      if (result instanceof Promise) {
        return result.catch(error => {
          this.#handle(error, errorMessage, options);

          return (options.fallback as T) ?? Promise.reject(error);
        });
      }

      return result;
    } catch (error) {
      this.#handle(error, errorMessage, options);

      return options.fallback as T;
    }
  }

  async handleAsync<T>(
    action: () => Promise<T>,
    errorMessage: string,
    options: ErrorHandlerOptions = {}
  ): Promise<T> {
    try {
      return await action();
    } catch (error) {
      this.#handle(error, errorMessage, options);

      throw error;
    }
  }

  handleSync<T>(
    action: () => T,
    errorMessage: string,
    options: ErrorHandlerOptions = {}
  ): T {
    try {
      return action();
    } catch (error) {
      this.#handle(error, errorMessage, options);

      throw error;
    }
  }

  #formatError(
    error: unknown,
    message: string,
    context: Record<string, unknown>
  ): string {
    try {
      return error instanceof Error
        ? `${message}: ${error.message}. Context: ${JSON.stringify(context)}`
        : `${message}: ${error}. Context: ${JSON.stringify(context)}`;
    } catch (error) {
      throw new Error(
        `[Error formatting error message: ${error instanceof Error ? error.message : error}`
      );
    }
  }

  #handle(
    error: unknown,
    errorMessage: string,
    options: ErrorHandlerOptions = {}
  ): void {
    try {
      const context: Record<string, unknown> =
        typeof options.context === 'object' && options.context !== null
          ? options.context
          : {};
      const formattedError = this.#formatError(error, errorMessage, context);
      this.#logger.error(formattedError);

      const userMessage =
        options.userMessage ??
        (error instanceof this.#errorClasses.UserFacingError
          ? error.userMessage
          : undefined);

      if (userMessage) {
        alert(userMessage);
      }
    } catch (error) {
      throw new Error(
        `Error handling error: ${error instanceof Error ? error.message : error}`
      );
    }
  }
}
// File: frontend/src/app/core/services/LoggerService.ts

import { Helpers, LoggerServiceContract } from '../../types/index.js';

// ================================================== //
// ================================================== //

export class Logger implements LoggerServiceContract {
  static #instance: Logger | null = null;

  private constructor(helpers: Helpers) {
    try {
      helpers.app.noop();
    } catch (error) {
      throw new Error(
        `constructor]: ${error instanceof Error ? error.message : error}`
      );
    }
  }

  static getInstance(helpers: Helpers): Logger {
    try {
      if (!Logger.#instance) {
        Logger.#instance = new Logger(helpers);

        console.log(
          `No existing Logger instance found. Creating new instance.`
        );
      }

      console.log(`Returning Logger instance.`);

      return Logger.#instance;
    } catch (error) {
      throw new Error(`${error instanceof Error ? error.message : error}`);
    }
  }

  debug(message: string, caller?: string): void {
    this.#logMessage(message, 'debug', caller);
  }

  error(message: string, caller?: string): void {
    this.#logMessage(message, 'error', caller);
  }

  info(message: string, caller?: string): void {
    this.#logMessage(message, 'info', caller);
  }

  warn(message: string, caller?: string): void {
    this.#logMessage(message, 'warn', caller);
  }

  #getFormattedTimestamp(): string {
    return new Date().toLocaleString('en-US', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    });
  }

  #getLevelColor(level: 'debug' | 'info' | 'warn' | 'error'): string {
    switch (level) {
      case 'debug':
        return 'color: green';
      case 'info':
        return 'color: blue';
      case 'warn':
        return 'color: orange';
      case 'error':
        return 'color: red';
      default:
        return 'color: black';
    }
  }

  #logMessage(
    message: string,
    level: 'debug' | 'info' | 'warn' | 'error',
    caller?: string
  ): void {
    const callerInfo = caller;
    const timestamp = this.#getFormattedTimestamp();

    try {
      console.log(
        `%c[${level.toUpperCase()}]%c ${timestamp} [${callerInfo}] %c${message}`,
        this.#getLevelColor(level),
        'color: gray',
        'color: inherit'
      );
    } catch (error) {
      console.error(
        `[${caller}.#logMessage]: Encountered an unexpected error: ${error}.`
      );
    }

    if (callerInfo === 'Unknown caller') {
      console.trace(`[${caller}]: Full Stack Trace:`);
    }
  }
}
// File: frontend/src/app/core/services/state/StateManager.ts

import type {
  CanvasState,
  ClientState,
  Core,
  GifAnimation,
  State,
  StateLifecycleHook,
  StateManagerContract,
  Subscriber,
  TextElement,
  VisualLayer
} from '../../../types/index.js';
import { CanvasStateService, ClientStateService } from '../index.js';

// ================================================== //
// ================================================== //

export class StateManager implements StateManagerContract {
  static #instance: StateManager | null = null;

  #version: string | null = null;
  #lifecycleHooks: StateLifecycleHook[] = [];

  #canvas: CanvasStateService;
  #client: ClientStateService;

  #data: Core['data'];
  #errors: Core['services']['errors'];
  #log: Core['services']['log'];

  // ================================================= //

  private constructor(
    data: Core['data'],
    errors: Core['services']['errors'],
    log: Core['services']['log']
  ) {
    try {
      log.info('Initializing StateManager...', '[StateManager constructor]');

      this.#data = data;
      this.#errors = errors;
      this.#log = log;
      this.#version = data.version;

      // hydrate state
      let initialState: State = {
        version: this.#data.version,
        canvas: {
          width: this.#data.config.defaults.canvasWidth,
          height: this.#data.config.defaults.canvasHeight,
          layers: [],
          selectedLayerIndex: null
        },
        client: {
          viewportWidth: window.innerWidth,
          viewportHeight: window.innerHeight
        }
      };

      const saved = window.localStorage.getItem('appState');

      if (saved) {
        try {
          Object.assign(initialState, JSON.parse(saved));
          log.info(
            `StateManager hydrated from localStorage.`,
            '[StateManager constructor]'
          );
        } catch (error) {
          log.warn(
            'Failed to parse localStorage state. Using default values.',
            '[StateManager constructor]'
          );
        }
      }

      this.#canvas = CanvasStateService.getInstance(
        initialState.canvas,
        this.#data
      );
      this.#client = ClientStateService.getInstance(initialState.client);

      this.#canvas.subscribe(() => this.#persistToStorage());
      this.#client.subscribe(() => this.#persistToStorage());

      log.info(
        'StateManager initialized successfully.',
        '[StateManager constructor]'
      );
    } catch (error) {
      throw new Error(
        `Failed to initialize StateManager: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  // ================================================== //

  static getInstance(
    data: Core['data'],
    errors: Core['services']['errors'],
    log: Core['services']['log']
  ): StateManager {
    try {
      log.info('Calling StateManager.getInstance()...');

      if (!StateManager.#instance) {
        log.info(
          'No existing StateManager instance found. Creating new instance.'
        );
        return (StateManager.#instance = new StateManager(data, errors, log));
      }

      log.info('Returning existing StateManager instance.');
      return StateManager.#instance;
    } catch (error) {
      throw new Error(
        `Failed to get StateManager instance: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  // ================================================= //
  // CORE CLASS METHODS //

  addLifecycleHook(hook: StateLifecycleHook): void {
    this.#errors.handleSync(() => {
      this.#log.info(
        'Adding lifecycle hook.',
        'StateManager.addLifecycleHook()'
      );

      if (typeof hook !== 'function') {
        throw new Error('Lifecycle hook must be a function.');
      }

      this.#lifecycleHooks.push(hook);
      this.#log.info(
        'Lifecycle hook added successfully.',
        'StateManager.addLifecycleHook()'
      );
    }, 'Failed to add lifecycle hook.');
  }

  getState(): State {
    return this.#errors.handleSync(() => {
      this.#log.info('Returning current state.', 'StateManager.getState()');

      return {
        version: this.#version!,
        canvas: this.getCanvas(),
        client: this.getClient()
      };
    }, 'Failed to return state.');
  }

  // ================================================= //
  // PROXY CANVAS STATE ACCESS //

  addLayer(layer: VisualLayer): void {
    this.#canvas.addLayer(layer);
    for (const hook of this.#lifecycleHooks) {
      hook('addLayer', this.getCanvas());
    }
  }
  addTextElement(elem: TextElement): void {
    this.#canvas.addTextElement(elem);
  }
  canRedoCanvas(): boolean {
    return this.#canvas.canRedo();
  }
  canUndoCanvas(): boolean {
    return this.#canvas.canUndo();
  }
  clearCanvasAll(): void {
    this.#canvas.clearAll();
    window.localStorage.setItem('appState', JSON.stringify(this.getState()));
  }
  clearCanvasAnimation(): void {
    this.#canvas.clearAnimation();
  }
  getCanvas(): CanvasState {
    return this.#canvas.get();
  }
  getCanvasAspectRatio(): number | undefined {
    return this.#canvas.getAspectRatio();
  }
  moveLayer(index: number, newIndex: number): void {
    this.#canvas.moveLayer(index, newIndex);
  }
  moveTextElement(index: number, x: number, y: number): void {
    this.#canvas.moveTextElement(index, x, y);
  }
  redoCanvas(): void {
    this.#canvas.redo();
  }
  removeLayer(index: number): void {
    this.#canvas.removeLayer(index);
  }
  removeTextElement(index: number): void {
    this.#canvas.removeTextElement(index);
  }
  resetCanvas(): void {
    this.#canvas.reset();
  }
  setCanvas(width: number, height: number): void {
    this.#canvas.set(width, height);
  }
  setCanvasAnimation(anim: GifAnimation | null): void {
    this.#canvas.setAnimation(anim);
  }
  setCanvasAspectRatio(aspect: number | undefined): void {
    this.#canvas.setAspectRatio(aspect);
  }
  setCanvasImage(imageDataUrl: string | undefined): void {
    this.#canvas.setCanvasImage(imageDataUrl);
  }
  setSelectedLayerIndex(index: number | null): void {
    this.#canvas.setSelectedLayerIndex(index);
  }
  subscribeToCanvas(fn: Subscriber<CanvasState>): () => void {
    return this.#canvas.subscribe(fn);
  }
  undoCanvas(): void {
    this.#canvas.undo();
  }
  updateLayer(index: number, newLayer: VisualLayer): void {
    this.#canvas.updateLayer(index, newLayer);
  }
  updateTextElement(index: number, newElem: TextElement): void {
    this.#canvas.updateTextElement(index, newElem);
  }

  // ================================================= //
  // PROXY CLIENT STATE ACCESS //

  getClient(): ClientState {
    return this.#client.get();
  }
  setClient(viewportWidth: number, viewportHeight: number): void {
    this.#client.set(viewportWidth, viewportHeight);
  }
  subscribeToClient(fn: Subscriber<ClientState>): () => void {
    return this.#client.subscribe(fn);
  }

  // ================================================= //
  // PRIVATE METHODS //

  #persistToStorage(): void {
    return this.#errors.handleSync(() => {
      window.localStorage.setItem('appState', JSON.stringify(this.getState()));
    }, 'Failed to persist state to localStorage.');
  }
}
// File: frontend/src/app/core/services/state/CanvasStateService.ts

import type {
  CanvasState,
  CanvasStateServiceContract,
  Data,
  GifAnimation,
  Subscriber,
  TextElement,
  TextVisualLayer,
  VisualLayer
} from '../../../types/index.js';

// ================================================== //
// ================================================== //

export class CanvasStateService implements CanvasStateServiceContract {
  static #instance: CanvasStateService | null = null;

  #canvasState: CanvasState;
  #subscribers: Set<Subscriber<CanvasState>>;

  #history: CanvasState[];
  #future: CanvasState[];

  #data: Data;

  // ================================================= //

  private constructor(initial: CanvasState, data: Data) {
    this.#canvasState = { ...initial };
    this.#canvasState.layers = initial.layers || [];
    this.#canvasState.selectedLayerIndex = initial.selectedLayerIndex ?? null;

    this.#subscribers = new Set();
    this.#history = [];
    this.#future = [];
    this.#data = data;
  }

  // ================================================= //

  static getInstance(initial: CanvasState, data: Data): CanvasStateService {
    try {
      if (!CanvasStateService.#instance) {
        CanvasStateService.#instance = new CanvasStateService(initial, data);
      }

      return CanvasStateService.#instance;
    } catch (error) {
      throw new Error(
        `Failed to get CanvasStateService instance: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  // ================================================= //

  addLayer(layer: VisualLayer): void {
    this.#history.push({ ...this.#canvasState });
    this.#canvasState.layers.push(layer);
    this.#notify();
  }

  addTextElement(elem: TextElement): void {
    let textLayer = this.#canvasState.layers.find(
      (layer): layer is TextVisualLayer => layer.type === 'text'
    );

    if (!textLayer) {
      textLayer = {
        id: crypto.randomUUID(),
        type: 'text',
        assetRef: {
          name: 'TextLayer',
          class: 'text',
          src: '',
          size_kb: 0,
          hash_sha256: '',
          extension: 'txt'
        },
        opacity: 1,
        visible: true,
        zIndex: this.#canvasState.layers.length,
        textElements: []
      };
      this.#canvasState.layers.push(textLayer);
    }

    textLayer.textElements!.push(elem);
    this.#notify();
  }

  canRedo(): boolean {
    return this.#future.length > 0;
  }

  canUndo(): boolean {
    return this.#history.length > 0;
  }

  clearAll(): void {
    this.#history.push({ ...this.#canvasState });
    this.#canvasState.layers = [];
    this.#canvasState.selectedLayerIndex = null;
    this.#notify();
  }

  clearAnimation(): void {
    this.setAnimation(null);
  }

  get(): CanvasState {
    return { ...this.#canvasState };
  }

  getAspectRatio(): number | undefined {
    return this.#canvasState.aspectRatio;
  }

  getLayers(): VisualLayer[] {
    return [...this.#canvasState.layers];
  }

  getSelectedLayerIndex(): number | null {
    return this.#canvasState.selectedLayerIndex;
  }

  moveLayer(index: number, newIndex: number): void {
    const [moved] = this.#canvasState.layers.splice(index, 1);
    this.#canvasState.layers.splice(newIndex, 0, moved);
    this.#notify();
  }

  moveTextElement(index: number, x: number, y: number): void {
    const textLayer = this.#canvasState.layers.find(
      (layer): layer is TextVisualLayer => layer.type === 'text'
    );

    if (textLayer) {
      const elem = textLayer.textElements[index];
      if (elem) {
        elem.x = x;
        elem.y = y;
        this.#notify();
      }
    }
  }

  redo(): void {
    if (this.#future.length > 0) {
      this.#history.push({ ...this.#canvasState });
      this.#canvasState = this.#future.pop()!;
      this.#notify();
    }
  }

  removeLayer(index: number): void {
    this.#history.push({ ...this.#canvasState });
    this.#canvasState.layers.splice(index, 1);
    this.#notify();
  }

  removeTextElement(index: number): void {
    const textLayer = this.#canvasState.layers.find(
      (layer): layer is TextVisualLayer => layer.type === 'text'
    );

    if (textLayer) {
      textLayer.textElements.splice(index, 1);
      this.#notify();
    }
  }

  reset() {
    this.set(
      this.#data.config.defaults.canvasWidth,
      this.#data.config.defaults.canvasHeight
    );
  }

  set(width: number, height: number): void {
    this.#history.push({ ...this.#canvasState });
    this.#future = [];
    this.#canvasState.width = width;
    this.#canvasState.height = height;
    this.#notify();
  }

  setAnimation(anim: GifAnimation | null): void {
    this.#canvasState.layers = this.#canvasState.layers.filter(
      layer => layer.type !== 'gif'
    );

    if (anim) {
      const gifLayer: VisualLayer = {
        id: crypto.randomUUID(),
        type: 'gif',
        assetRef: {
          name: 'GifAnimation',
          class: 'gif',
          src: '',
          size_kb: 0,
          hash_sha256: '',
          extension: 'gif'
        },
        opacity: 1,
        visible: true,
        zIndex: this.#canvasState.layers.length,
        gifFrames: anim.frames,
        currentFrame: 0,
        frameElapsed: 0,
        position: { x: 0, y: 0 },
        scale: { x: 1, y: 1 },
        rotation: {
          speed: 0,
          direction: 'n/a',
          currentAngle: 0
        }
      };

      this.#canvasState.layers.push(gifLayer);
    }

    this.#notify();
  }

  setAspectRatio(aspect: number | undefined): void {
    this.#canvasState.aspectRatio = aspect;
    this.#notify();
  }

  setCanvasImage(imageDataUrl: string | undefined): void {
    this.#canvasState.layers = this.#canvasState.layers.filter(
      layer => layer.type !== 'image'
    );

    if (imageDataUrl) {
      const img = new Image();
      img.src = imageDataUrl;

      const imageLayer: VisualLayer = {
        id: crypto.randomUUID(),
        type: 'image',
        assetRef: {
          name: 'ImageLayer',
          src: imageDataUrl,
          class: 'image',
          size_kb: 0,
          hash_sha256: '',
          extension: 'png'
        },
        opacity: 1,
        visible: true,
        zIndex: 0,
        element: img,
        position: { x: 0, y: 0 },
        scale: { x: 1, y: 1 },
        rotation: {
          speed: 0,
          direction: 'n/a',
          currentAngle: 0
        }
      };

      this.#canvasState.layers.unshift(imageLayer);
    }

    this.#notify();
  }

  setSelectedLayerIndex(index: number | null): void {
    this.#canvasState.selectedLayerIndex = index;
    this.#notify();
  }

  subscribe(fn: Subscriber<CanvasState>) {
    this.#subscribers.add(fn);
    fn(this.get());
    return () => this.#subscribers.delete(fn);
  }

  undo(): void {
    if (this.#history.length > 0) {
      this.#future.push({ ...this.#canvasState });
      this.#canvasState = this.#history.pop()!;
      this.#notify();
    }
  }

  updateLayer(index: number, newLayer: VisualLayer): void {
    this.#canvasState.layers[index] = newLayer;
    this.#notify();
  }

  updateTextElement(index: number, newElem: TextElement): void {
    const textLayer = this.#canvasState.layers.find(
      (layer): layer is TextVisualLayer => layer.type === 'text'
    );

    if (textLayer) {
      textLayer.textElements[index] = newElem;
      this.#notify();
    }
  }

  // ================================================= //

  #notify(): void {
    const state = this.get();
    for (const fn of this.#subscribers) fn(state);
  }
}
// File: frontend/src/app/core/services/state/ClientStateService.ts

import type {
  ClientState,
  ClientStateServiceContract,
  Subscriber
} from '../../../types/index.js';

// ================================================== //
// ================================================== //

export class ClientStateService implements ClientStateServiceContract {
  static #instance: ClientStateService | null = null;

  #state: ClientState;
  #subscribers: Set<Subscriber<ClientState>>;

  // ------------------------------------------------ //

  private constructor(initial: ClientState) {
    this.#state = { ...initial };
    this.#subscribers = new Set();
  }

  // ------------------------------------------------ //

  static getInstance(initial: ClientState): ClientStateService {
    try {
      if (!ClientStateService.#instance) {
        ClientStateService.#instance = new ClientStateService(initial);
      }

      return ClientStateService.#instance;
    } catch (error) {
      throw new Error(
        `Failed to get ClientStateService instance: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  // ------------------------------------------------ //

  get(): ClientState {
    return { ...this.#state };
  }
