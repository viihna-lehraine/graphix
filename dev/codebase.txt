========= Codebase Overview =========
Project Root: /home/viihna/Projects/graphix
Output File: /home/viihna/Projects/graphix/dev/codebase.txt

========= index.html =========
<!-- File: frontend/src/index.html -->

<!doctype html>

<html lang="en">

  <head>
    <title>Graphix</title>
    <meta charset="UTF-8" />
    <meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, shrink-to-fit=no"
		/>
    <meta name="author" content="Viihna Lehraine" />
    <meta
      name="description"
      content="Remember Blinkies? Yeah we bringin' that shit back mafucka."
    />
    <link
      rel="icon"
      type="image/svg+xml"
      href="/assets/icons/favicon.svg"
    />
    <link
      rel="shortcut icon"
      type="image/png"
      href="/assets/icons/favicon-android-chrome.png"
    />
    <link
      rel="stylesheet"
      href="styles/main.css"
    />
  </head>

  <body>

    <div id="app">
      <header>
        <div class="header-div">
          <h1>T E S T I C L E S</h1>
      </div>
      </header>

      <main class="main-area">

        <div class="main-div">
          <section class="canvas-field">
            <div id="canvas-container">
              <canvas id="main-canvas"></canvas>
            </div>
          </section>

          <aside class="tray tray--extras">
            <div class="canvas-toolbar">
              <input type="file" accept=".gif,.jpg,.jpeg,.png" id="img-upload-input" class="hidden" />
              <button id="upload-btn" class="canvas-btn">Upload</button>
              <button id="download-btn" class="canvas-btn">Download</button>
              <button id="clear-btn" class="canvas-btn">Clear</button>
            </div>
            <div>
              <h2>Add Text</h2>
              <form id="text-form">
                <input type="text" id="text-input" placeholder="Add text here :3" />
                <button type="submit" id="add-text-btn">Add</button>
              </form>
            </div>
            <div class="asset-browser-subpanel">
              <button id="toggle-asset-browser-btn" class="canvas-btn">Browse Assets</button>
            </div>
            <div id="asset-browser" class="asset-browser"></div>
            <div id="properties-panel" class="properties-panel"></div>
          </aside>
        </div>

      </main>

      <footer>
        <div class="footer-div">
          <span>
            Made with 💖 by <a href="https://github.com/viihna-lehraine/graphix">Viihna Lehraine</a>🦈
          </span>
        </div>
      </footer>

    </div>

    <script type="module" src="app/main.ts"></script>

  </body>

</html>


====== .ts files ======
--- /home/viihna/Projects/graphix/frontend/src/app/core/config/errors.ts ---
// File: frontend/src/app/core/config/errors.ts

class UserFacingError extends Error {
  constructor(
    message: string,
    public userMessage?: string
  ) {
    super(message);
    this.name = 'UserFacingError';
  }
}

export interface ErrorClasses {
  UserFacingError: typeof UserFacingError;
}

// ================================================== //

export const errorClasses: ErrorClasses = {
  UserFacingError
} as const;

--- /home/viihna/Projects/graphix/frontend/src/app/core/config/manifest.ts ---
// File: frontend/src/app/core/config/manifest.ts

import type { AssetManifestEntry } from '../../types/index.js';

export async function loadAssetManifest(): Promise<AssetManifestEntry[]> {
  const resp = await fetch('/assets/userManifest.json');
  if (!resp.ok)
    throw new Error(`Failed to load asset manifest: ${resp.statusText}`);
  return resp.json();
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/factories/helpers.ts ---
// File: frontend/src/app/core/factories/helpers.ts

import type { Helpers } from '../../types/index.js';

// ================================================== //

export async function helpersFactory(): Promise<Required<Helpers>> {
  console.log(`Creating 'Helpers' object`);

  const helpers = {} as Helpers;

  const [
    { appHelpersFactory },
    { canvasHelpersFactory },
    { dataHelperFactory },
    { mathHelpersFactory },
    { timeHelpersFactory }
  ] = await Promise.all([
    import('../helpers/app.js'),
    import('../helpers/canvas.js'),
    import('../helpers/data.js'),
    import('../helpers/math.js'),
    import('../helpers/time.js')
  ]);

  helpers.app = appHelpersFactory();
  helpers.canvas = canvasHelpersFactory();
  helpers.data = await dataHelperFactory();
  helpers.math = mathHelpersFactory();
  helpers.time = timeHelpersFactory();

  console.log(`Helpers object has been successfully created`);

  return helpers;
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/factories/services.ts ---
// File: frontend/src/app/core/factories/services.ts

import type { Data, Helpers, Services } from '../../types/index.js';
import {
  AnimationGroupManager,
  CacheManager,
  ErrorHandler,
  Logger,
  ResizeManager,
  StateManager,
  StorageManager
} from '../services/index.js';

// ================================================== //

export async function serviceFactory(
  data: Data,
  helpers: Helpers
): Promise<Required<Services>> {
  console.log(`Starting service factory...`);
  const services = {} as Services;

  console.log(`Initializing Logger, ErrorHandler, and StateManager services`);

  services.log = Logger.getInstance(helpers);
  services.errors = ErrorHandler.getInstance(services.log);
  services.storageManager = await StorageManager.getInstance();
  services.stateManager = StateManager.getInstance(
    data,
    services.errors,
    services.log
  );
  services.cache = CacheManager.getInstance(services.errors, services.log);
  services.resizeManager = ResizeManager.getInstance(
    services.errors,
    services.log
  );
  services.animationGroupManager = AnimationGroupManager.getInstance();

  if (!services.log || !services.errors) {
    throw new Error(`Logger and/or ErrorHandler failed to initialize.`);
  }

  return services;
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/factories/utilities.ts ---
// File: frontend/src/app/core/factories/utilities.ts

import type {
  CanvasUtils,
  DataUtils,
  DomUtils,
  MathUtils,
  Services,
  Utilities
} from '../../types/index.js';

export async function utilitiesFactory(
  services: Services
): Promise<Required<Utilities>> {
  const { errors, log } = services;

  return errors.handleAsync(async () => {
    log.info(`Creating 'Utilities' object.`);

    const utils = {} as Utilities;
    const { canvasUtilityFactory } = await import('../utils/canvas.js');
    const { dataUtilityFactory } = await import('../utils/data.js');
    const { domUtilityFactory } = await import('../utils/dom.js');
    const { mathUtilityFactory } = await import('../utils/math.js');

    const canvasUtils: CanvasUtils = canvasUtilityFactory();
    const dataUtils: DataUtils = dataUtilityFactory();
    const domUtils: DomUtils = domUtilityFactory();
    const mathUtils: MathUtils = mathUtilityFactory();

    utils.canvas = canvasUtils;
    utils.data = dataUtils;
    utils.dom = domUtils;
    utils.math = mathUtils;

    log.info(`'Utilities' object has been successfully created.`);

    return utils;
  }, `Utilities initialization failed.`);
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/helpers/app.ts ---
// File: frontend/src/app/core/helpers/app.ts

import { Helpers } from '../../types/index.js';

export const appHelpersFactory = (): Helpers['app'] => ({
  noop(): void {}
});

--- /home/viihna/Projects/graphix/frontend/src/app/core/helpers/canvas.ts ---
// File: frontend/src/app/core/helpers/canvas.ts

import type { CanvasHelpers, TextElement } from '../../types/index.js';

// ================================================== //

export const canvasHelpersFactory = (): CanvasHelpers => {
  return {
    get2DContext(canvas: HTMLCanvasElement): CanvasRenderingContext2D {
      const ctx = canvas.getContext('2d');
      if (!ctx) throw new Error('2D canvas context is not available!');

      return ctx;
    },

    getMousePosition(
      canvas: HTMLCanvasElement,
      evt: MouseEvent
    ): {
      x: number;
      y: number;
    } {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      return {
        x: (evt.clientX - rect.left) * scaleX,
        y: (evt.clientY - rect.top) * scaleY
      };
    },

    isOverResizeHandle(
      mouse: { x: number; y: number },
      elem: TextElement,
      ctx: CanvasRenderingContext2D
    ): boolean {
      const fontSize = elem.fontSize ?? 32;
      const fontWeight = elem.fontWeight ?? 'bold';
      const fontFamily = elem.fontFamily ?? 'sans-serif';
      ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;

      const width = ctx.measureText(elem.text).width;
      const height = fontSize;

      const handleSize = 10;
      const handleX = elem.x + width / 2 - handleSize / 2;
      const handleY = elem.y + height / 2 - handleSize / 2;

      return (
        mouse.x >= handleX &&
        mouse.x <= handleX + handleSize &&
        mouse.y >= handleY &&
        mouse.y <= handleY + handleSize
      );
    },

    isPointInText(
      pt: { x: number; y: number },
      elem: TextElement,
      ctx: CanvasRenderingContext2D
    ): boolean {
      ctx.save();

      const fontSize = elem.fontSize ?? 32;
      const fontWeight = elem.fontWeight ?? 'bold';
      const fontFamily = elem.fontFamily ?? 'sans-serif';
      ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;

      const width = ctx.measureText(elem.text).width;
      const height = fontSize;
      ctx.restore();

      return (
        pt.x >= elem.x - width / 2 &&
        pt.x <= elem.x + width / 2 &&
        pt.y >= elem.y - height / 2 &&
        pt.y <= elem.y + height / 2
      );
    },

    mapBlendMode(blendMode?: string): GlobalCompositeOperation {
      if (!blendMode || blendMode === 'normal') {
        return 'source-over';
      }

      return blendMode as GlobalCompositeOperation;
    }
  };
};

--- /home/viihna/Projects/graphix/frontend/src/app/core/helpers/data.ts ---
// File: frontend/src/app/core/helpers/data.ts

import type { DataHelpers } from '../../types/index.js';

export const dataHelperFactory = async (): Promise<DataHelpers> => ({
  clone<T>(data: T): T {
    return structuredClone(data);
  },

  getFileSizeInKB(file: File | Blob): number {
    return Math.round(file.size / 1024);
  },

  async getFileSHA256(file: File | Blob): Promise<string> {
    const buf = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', buf);
    const hashArray = Array.from(new Uint8Array(hashBuffer));

    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }
});

--- /home/viihna/Projects/graphix/frontend/src/app/core/helpers/math.ts ---
// File: frontend/src/app/core/helpers/math.ts

import { MathHelpers } from '../../types/index.js';

export const mathHelpersFactory = (): MathHelpers => ({
  weightedRandom(min: number, max: number, weight: number): number {
    const t = Math.pow(Math.random(), weight);
    return min + t * (max - min);
  }
});

--- /home/viihna/Projects/graphix/frontend/src/app/core/helpers/time.ts ---
// File: frontend/src/app/cpre/helpers/time.ts

import type { Data, Helpers } from '../../types/index.js';

const { data } = await import('../../data/index.js');
const defaultDebounceWait: Data['config']['defaults']['debounceWait'] =
  data.config.defaults.debounceWait;

// ================================================== //

export const timeHelpersFactory = (): Helpers['time'] => ({
  debounce<T extends (...args: Record<string, unknown>[]) => void>(
    fn: T,
    wait?: number
  ): (...args: Parameters<T>) => void {
    let timeout: ReturnType<typeof setTimeout> | null = null;

    if (!wait) wait = defaultDebounceWait;

    return function (...args: Parameters<T>) {
      if (timeout) clearTimeout(timeout);

      timeout = setTimeout(() => fn(...args), wait);
    };
  }
});

--- /home/viihna/Projects/graphix/frontend/src/app/core/services/AnimationGroupManager.ts ---
// File: frontend/src/app/core/services/AnimationGroupManager.ts

import type {
  AnimationGroup,
  AnimationGroupManagerContract
} from '../../types/index.js';

// ================================================== //
// ================================================== //

export class AnimationGroupManager implements AnimationGroupManagerContract {
  static #instance: AnimationGroupManager | null = null;

  #groups: AnimationGroup[] = [];

  private constructor() {}

  static getInstance(): AnimationGroupManager {
    if (!this.#instance) {
      this.#instance = new AnimationGroupManager();
    }
    return this.#instance;
  }

  get groups(): AnimationGroup[] {
    return this.#groups;
  }

  addGroup(group: AnimationGroup): void {
    this.#groups.push(group);
  }

  pause(groupId: string): void {
    const group = this.#groups.find(g => g.id === groupId);
    if (group) group.isPlaying = false;
  }

  play(groupId: string): void {
    const group = this.#groups.find(g => g.id === groupId);
    if (group) group.isPlaying = true;
  }

  removeGroup(groupId: string): void {
    this.#groups = this.#groups.filter(g => g.id !== groupId);
  }

  update(deltaTime: number): void {
    this.#groups.forEach(group => {
      if (!group.isPlaying) return;

      group.layers.forEach(layer => {
        // advance rotation if present
        if (layer.rotation && layer.rotation.direction !== 'n/a') {
          const dirFactor = layer.rotation.direction === 'clockwise' ? 1 : -1;
          layer.rotation.currentAngle =
            (layer.rotation.currentAngle +
              dirFactor * layer.rotation.speed * deltaTime) %
            360;
        }

        // advance GIF frames if applicable
        if (layer.type === 'gif') {
          layer.frameElapsed = (layer.frameElapsed ?? 0) + deltaTime * 1000;

          const frameDuration = 1000 / (layer.animationProps?.frames.rate || 1);

          while (layer.frameElapsed >= frameDuration) {
            layer.frameElapsed -= frameDuration;
            layer.currentFrame =
              ((layer.currentFrame ?? 0) + 1) % layer.gifFrames.length;
          }
        }
      });
    });
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/services/CacheManager.ts ---
// File: frontend/src/app/core/services/CanvasCacheService.ts

import type {
  Cache,
  CacheManagerContract,
  Services
} from '../../types/index.js';

// ======================================================== //
// ======================================================== //

export class CacheManager implements CacheManagerContract {
  static #instance: CacheManager | null = null;

  #cache = {} as Cache;

  #errors: Services['errors'];
  #log: Services['log'];

  // ====================================================== //

  private constructor(errors: Services['errors'], log: Services['log']) {
    try {
      this.#errors = errors;
      this.#log = log;

      if (CacheManager.#instance) {
        throw new Error(
          'CanvasCacheService is a singleton and cannot be instantiated multiple times.'
        );
      }

      CacheManager.#instance = this;
    } catch (error) {
      throw new Error('Unhandled CanvasCacheService initialization error.');
    }
  }

  // ====================================================== //

  public static getInstance(
    errors: Services['errors'],
    log: Services['log']
  ): CacheManager {
    return errors.handleSync(() => {
      if (!CacheManager.#instance) {
        log.info('Creating CanvasCacheService instance.');
        CacheManager.#instance = new CacheManager(errors, log);
      }

      log.info('Returning existing CanvasCacheService instance.');
      return CacheManager.#instance;
    }, 'Unhandled CanvasCacheService getInstance error.');
  }

  // ====================================================== //

  get cachedBgImg(): HTMLImageElement | null {
    return this.#errors.handleSync(() => {
      this.#log.debug('Returning cached canvas background img');
      return this.#cache.bgImg;
    }, 'Unhandled CanvasCacheService cachedBgImg getter error.');
  }

  set cachedBgImg(img: HTMLImageElement | null) {
    this.#errors.handleSync(() => {
      this.#cache.bgImg = img;
    }, 'Unhandled CanvasCacheService cachedBgImg setter error.');
  }

  // ====================================================== //

  clearAll(): void {
    this.#errors.handleSync(() => {
      this.#cache.bgImg = null;
    }, 'Unhandled CanvasCacheService clearAll error.');
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/services/ErrorHandler.ts ---
// File: frontend/src/app/core/services/ErrorHandler.ts

import {
  ErrorHandlerServiceContract,
  ErrorHandlerOptions
} from '../../types/index.js';
import { errorClasses, ErrorClasses } from '../config/errors.js';
import { Logger } from './Logger.js';

// ================================================== //
// ================================================== //

export class ErrorHandler implements ErrorHandlerServiceContract {
  static #instance: ErrorHandler | null = null;
  #errorClasses: ErrorClasses = errorClasses;
  #logger: Logger;

  private constructor(logger: Logger) {
    try {
      this.#logger = logger;
    } catch (error) {
      throw new Error(`${error instanceof Error ? error.message : error}`);
    }
  }

  static getInstance(logger: Logger): ErrorHandler {
    try {
      if (!ErrorHandler.#instance) {
        console.debug(
          `No ErrorHandler instance exists yet. Creating new instance.`
        );
        ErrorHandler.#instance = new ErrorHandler(logger);
      }

      console.debug(`Returning ErrorHandler instance.`);

      return ErrorHandler.#instance;
    } catch (error) {
      throw new Error(`${error instanceof Error ? error.message : error}`);
    }
  }

  handleAndReturn<T>(
    action: () => T | Promise<T>,
    errorMessage: string,
    options: ErrorHandlerOptions = {}
  ): T | Promise<T> {
    try {
      const result = action();

      if (result instanceof Promise) {
        return result.catch(error => {
          this.#handle(error, errorMessage, options);

          return (options.fallback as T) ?? Promise.reject(error);
        });
      }

      return result;
    } catch (error) {
      this.#handle(error, errorMessage, options);

      return options.fallback as T;
    }
  }

  async handleAsync<T>(
    action: () => Promise<T>,
    errorMessage: string,
    options: ErrorHandlerOptions = {}
  ): Promise<T> {
    try {
      return await action();
    } catch (error) {
      this.#handle(error, errorMessage, options);

      throw error;
    }
  }

  handleSync<T>(
    action: () => T,
    errorMessage: string,
    options: ErrorHandlerOptions = {}
  ): T {
    try {
      return action();
    } catch (error) {
      this.#handle(error, errorMessage, options);

      throw error;
    }
  }

  #formatError(
    error: unknown,
    message: string,
    context: Record<string, unknown>
  ): string {
    try {
      return error instanceof Error
        ? `${message}: ${error.message}. Context: ${JSON.stringify(context)}`
        : `${message}: ${error}. Context: ${JSON.stringify(context)}`;
    } catch (error) {
      throw new Error(
        `[Error formatting error message: ${error instanceof Error ? error.message : error}`
      );
    }
  }

  #handle(
    error: unknown,
    errorMessage: string,
    options: ErrorHandlerOptions = {}
  ): void {
    try {
      const context: Record<string, unknown> =
        typeof options.context === 'object' && options.context !== null
          ? options.context
          : {};
      const formattedError = this.#formatError(error, errorMessage, context);
      this.#logger.error(formattedError);

      const userMessage =
        options.userMessage ??
        (error instanceof this.#errorClasses.UserFacingError
          ? error.userMessage
          : undefined);

      if (userMessage) {
        alert(userMessage);
      }
    } catch (error) {
      throw new Error(
        `Error handling error: ${error instanceof Error ? error.message : error}`
      );
    }
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/services/index.ts ---
// File: frontend/src/app/core/services/index.ts

export { AnimationGroupManager } from './AnimationGroupManager.js';
export { CacheManager } from './CacheManager.js';
export { CanvasStateService } from './state/CanvasStateService.js';
export { ClientStateService } from './state/ClientStateService.js';
export { ErrorHandler } from './ErrorHandler.js';
export { IDBStorageService } from './storage/IDBStorageService.js';
export { LocalStorageService } from './storage/LocalStorageService.js';
export { Logger } from './Logger.js';
export { ResizeManager } from './ResizeManager.js';
export { StateManager } from './state/StateManager.js';
export { StorageManager } from './storage/StorageManager.js';

--- /home/viihna/Projects/graphix/frontend/src/app/core/services/Logger.ts ---
// File: frontend/src/app/core/services/LoggerService.ts

import { Helpers, LoggerServiceContract } from '../../types/index.js';

// ================================================== //
// ================================================== //

export class Logger implements LoggerServiceContract {
  static #instance: Logger | null = null;

  private constructor(helpers: Helpers) {
    try {
      helpers.app.noop();
    } catch (error) {
      throw new Error(
        `constructor]: ${error instanceof Error ? error.message : error}`
      );
    }
  }

  static getInstance(helpers: Helpers): Logger {
    try {
      if (!Logger.#instance) {
        Logger.#instance = new Logger(helpers);

        console.log(
          `No existing Logger instance found. Creating new instance.`
        );
      }

      console.log(`Returning Logger instance.`);

      return Logger.#instance;
    } catch (error) {
      throw new Error(`${error instanceof Error ? error.message : error}`);
    }
  }

  debug(message: string, caller?: string): void {
    this.#logMessage(message, 'debug', caller);
  }

  error(message: string, caller?: string): void {
    this.#logMessage(message, 'error', caller);
  }

  info(message: string, caller?: string): void {
    this.#logMessage(message, 'info', caller);
  }

  warn(message: string, caller?: string): void {
    this.#logMessage(message, 'warn', caller);
  }

  #getFormattedTimestamp(): string {
    return new Date().toLocaleString('en-US', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    });
  }

  #getLevelColor(level: 'debug' | 'info' | 'warn' | 'error'): string {
    switch (level) {
      case 'debug':
        return 'color: green';
      case 'info':
        return 'color: blue';
      case 'warn':
        return 'color: orange';
      case 'error':
        return 'color: red';
      default:
        return 'color: black';
    }
  }

  #logMessage(
    message: string,
    level: 'debug' | 'info' | 'warn' | 'error',
    caller?: string
  ): void {
    const callerInfo = caller;
    const timestamp = this.#getFormattedTimestamp();

    try {
      console.log(
        `%c[${level.toUpperCase()}]%c ${timestamp} [${callerInfo}] %c${message}`,
        this.#getLevelColor(level),
        'color: gray',
        'color: inherit'
      );
    } catch (error) {
      console.error(
        `[${caller}.#logMessage]: Encountered an unexpected error: ${error}.`
      );
    }

    if (callerInfo === 'Unknown caller') {
      console.trace(`[${caller}]: Full Stack Trace:`);
    }
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/services/Notifier.ts ---
// File: frontend/src/app/core/services/Notifier.ts

import type {
  NotifierLevel,
  NotifierServiceContract
} from '../../types/index.js';

// =================================================== //
// =================================================== //

export class Notifier implements NotifierServiceContract {
  static #instance: Notifier | null = null;

  private constructor() {}

  static getInstance(): Notifier {
    if (!Notifier.#instance) {
      Notifier.#instance = new Notifier();
    }
    return Notifier.#instance;
  }

  // ================================================== //

  notify(message: string, level: NotifierLevel = 'warn'): void {
    switch (level) {
      case 'info':
        alert(`ℹ️ ${message}`);
        break;
      case 'warn':
        alert(`⚠️ ${message}`);
        break;
      case 'error':
        alert(`❌ ${message}`);
        break;
      case 'success':
        alert(`✅ ${message}`);
        break;
    }
  }

  // ================================================== //

  info(message: string): void {
    this.notify(message, 'info');
  }
  warn(message: string): void {
    this.notify(message, 'warn');
  }
  error(message: string): void {
    this.notify(message, 'error');
  }
  success(message: string): void {
    this.notify(message, 'success');
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/services/ResizeManager.ts ---
// File: frontend/src/app/core/services/dom/ResizeManager.ts

import type {
  ResizeManagerContract,
  ResizePlugin,
  Services
} from '../../types/index.js';

// =================================================== //
// =================================================== //

export class ResizeManager implements ResizeManagerContract {
  static #instance: ResizeManager | null = null;

  // #debounceTimeout: number | null = null;
  #plugins: Set<ResizePlugin> = new Set();

  #errors: Services['errors'];
  #log: Services['log'];

  // =================================================== //

  private constructor(errors: Services['errors'], log: Services['log']) {
    try {
      log.info('Initializing ResizeManager...');

      this.#errors = errors;
      this.#log = log;

      this.initialize();

      log.info('ResizeManager initialized successfully.');
    } catch (error) {
      throw new Error(
        `Failed to initialize ResizeManager: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  // =================================================== //

  static getInstance(
    errors: Services['errors'],
    log: Services['log']
  ): ResizeManager {
    try {
      if (!ResizeManager.#instance) {
        ResizeManager.#instance = new ResizeManager(errors, log);
      }

      return ResizeManager.#instance;
    } catch (error) {
      throw new Error(
        `Failed to get ResizeManager instance: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  // =================================================== //

  initialize(): void {
    this.#errors.handleSync(() => {
      this.#log.info('Registering Window Resize event listeners...');

      // window.addEventListener('resize', this.debouncedRunAll);
      document.addEventListener('DOMContentLoaded', this.runAll.bind(this));
    }, 'ResizeManager initialization failed.');
  }

  // =================================================== //

  register(plugin: ResizePlugin): void {
    this.#plugins.add(plugin);
  }

  // =================================================== //

  runAll(): void {
    this.#plugins.forEach(fn => {
      try {
        fn();
      } catch (err) {
        console.error('[ResizeManager] Plugin error:', err);
      }
    });
  }

  // =================================================== //

  unregister(plugin: ResizePlugin): void {
    this.#plugins.delete(plugin);
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/services/state/CanvasStateService.ts ---
// File: frontend/src/app/core/services/state/CanvasStateService.ts

import type {
  CanvasState,
  CanvasStateServiceContract,
  Data,
  GifAnimation,
  Subscriber,
  TextElement,
  TextVisualLayer,
  VisualLayer
} from '../../../types/index.js';

// ================================================== //
// ================================================== //

export class CanvasStateService implements CanvasStateServiceContract {
  static #instance: CanvasStateService | null = null;

  #canvasState: CanvasState;
  #subscribers: Set<Subscriber<CanvasState>>;

  #history: CanvasState[];
  #future: CanvasState[];

  #data: Data;

  // ================================================= //

  private constructor(initial: CanvasState, data: Data) {
    this.#canvasState = { ...initial };
    this.#canvasState.layers = initial.layers || [];
    this.#canvasState.selectedLayerIndex = initial.selectedLayerIndex ?? null;

    this.#subscribers = new Set();
    this.#history = [];
    this.#future = [];
    this.#data = data;
  }

  // ================================================= //

  static getInstance(initial: CanvasState, data: Data): CanvasStateService {
    try {
      if (!CanvasStateService.#instance) {
        CanvasStateService.#instance = new CanvasStateService(initial, data);
      }

      return CanvasStateService.#instance;
    } catch (error) {
      throw new Error(
        `Failed to get CanvasStateService instance: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  // ================================================= //

  addLayer(layer: VisualLayer): void {
    this.#history.push({ ...this.#canvasState });
    this.#canvasState.layers.push(layer);
    this.#notify();
  }

  addTextElement(elem: TextElement): void {
    let textLayer = this.#canvasState.layers.find(
      (layer): layer is TextVisualLayer => layer.type === 'text'
    );

    if (!textLayer) {
      textLayer = {
        id: crypto.randomUUID(),
        type: 'text',
        assetRef: {
          name: 'TextLayer',
          class: 'text',
          src: '',
          size_kb: 0,
          hash_sha256: '',
          extension: 'txt'
        },
        opacity: 1,
        visible: true,
        zIndex: this.#canvasState.layers.length,
        textElements: []
      };
      this.#canvasState.layers.push(textLayer);
    }

    textLayer.textElements!.push(elem);
    this.#notify();
  }

  canRedo(): boolean {
    return this.#future.length > 0;
  }

  canUndo(): boolean {
    return this.#history.length > 0;
  }

  clearAll(): void {
    this.#history.push({ ...this.#canvasState });
    this.#canvasState.layers = [];
    this.#canvasState.selectedLayerIndex = null;
    this.#notify();
  }

  clearAnimation(): void {
    this.setAnimation(null);
  }

  get(): CanvasState {
    return { ...this.#canvasState };
  }

  getAspectRatio(): number | undefined {
    return this.#canvasState.aspectRatio;
  }

  getLayers(): VisualLayer[] {
    return [...this.#canvasState.layers];
  }

  getSelectedLayerIndex(): number | null {
    return this.#canvasState.selectedLayerIndex;
  }

  moveLayer(index: number, newIndex: number): void {
    const [moved] = this.#canvasState.layers.splice(index, 1);
    this.#canvasState.layers.splice(newIndex, 0, moved);
    this.#notify();
  }

  moveTextElement(index: number, x: number, y: number): void {
    const textLayer = this.#canvasState.layers.find(
      (layer): layer is TextVisualLayer => layer.type === 'text'
    );

    if (textLayer) {
      const elem = textLayer.textElements[index];
      if (elem) {
        elem.x = x;
        elem.y = y;
        this.#notify();
      }
    }
  }

  redo(): void {
    if (this.#future.length > 0) {
      this.#history.push({ ...this.#canvasState });
      this.#canvasState = this.#future.pop()!;
      this.#notify();
    }
  }

  removeLayer(index: number): void {
    this.#history.push({ ...this.#canvasState });
    this.#canvasState.layers.splice(index, 1);
    this.#notify();
  }

  removeTextElement(index: number): void {
    const textLayer = this.#canvasState.layers.find(
      (layer): layer is TextVisualLayer => layer.type === 'text'
    );

    if (textLayer) {
      textLayer.textElements.splice(index, 1);
      this.#notify();
    }
  }

  reset() {
    this.set(
      this.#data.config.defaults.canvasWidth,
      this.#data.config.defaults.canvasHeight
    );
  }

  set(width: number, height: number): void {
    this.#history.push({ ...this.#canvasState });
    this.#future = [];
    this.#canvasState.width = width;
    this.#canvasState.height = height;
    this.#notify();
  }

  setAnimation(anim: GifAnimation | null): void {
    this.#canvasState.layers = this.#canvasState.layers.filter(
      layer => layer.type !== 'gif'
    );

    if (anim) {
      const gifLayer: VisualLayer = {
        id: crypto.randomUUID(),
        type: 'gif',
        assetRef: {
          name: 'GifAnimation',
          class: 'gif',
          src: '',
          size_kb: 0,
          hash_sha256: '',
          extension: 'gif'
        },
        opacity: 1,
        visible: true,
        zIndex: this.#canvasState.layers.length,
        gifFrames: anim.frames,
        currentFrame: 0,
        frameElapsed: 0,
        position: { x: 0, y: 0 },
        scale: { x: 1, y: 1 },
        rotation: {
          speed: 0,
          direction: 'n/a',
          currentAngle: 0
        }
      };

      this.#canvasState.layers.push(gifLayer);
    }

    this.#notify();
  }

  setAspectRatio(aspect: number | undefined): void {
    this.#canvasState.aspectRatio = aspect;
    this.#notify();
  }

  setCanvasImage(imageDataUrl: string | undefined): void {
    this.#canvasState.layers = this.#canvasState.layers.filter(
      layer => layer.type !== 'image'
    );

    if (imageDataUrl) {
      const img = new Image();
      img.src = imageDataUrl;

      const imageLayer: VisualLayer = {
        id: crypto.randomUUID(),
        type: 'image',
        assetRef: {
          name: 'ImageLayer',
          src: imageDataUrl,
          class: 'image',
          size_kb: 0,
          hash_sha256: '',
          extension: 'png'
        },
        opacity: 1,
        visible: true,
        zIndex: 0,
        element: img,
        position: { x: 0, y: 0 },
        scale: { x: 1, y: 1 },
        rotation: {
          speed: 0,
          direction: 'n/a',
          currentAngle: 0
        }
      };

      this.#canvasState.layers.unshift(imageLayer);
    }

    this.#notify();
  }

  setSelectedLayerIndex(index: number | null): void {
    this.#canvasState.selectedLayerIndex = index;
    this.#notify();
  }

  subscribe(fn: Subscriber<CanvasState>) {
    this.#subscribers.add(fn);
    fn(this.get());
    return () => this.#subscribers.delete(fn);
  }

  undo(): void {
    if (this.#history.length > 0) {
      this.#future.push({ ...this.#canvasState });
      this.#canvasState = this.#history.pop()!;
      this.#notify();
    }
  }

  updateLayer(index: number, newLayer: VisualLayer): void {
    this.#canvasState.layers[index] = newLayer;
    this.#notify();
  }

  updateTextElement(index: number, newElem: TextElement): void {
    const textLayer = this.#canvasState.layers.find(
      (layer): layer is TextVisualLayer => layer.type === 'text'
    );

    if (textLayer) {
      textLayer.textElements[index] = newElem;
      this.#notify();
    }
  }

  // ================================================= //

  #notify(): void {
    const state = this.get();
    for (const fn of this.#subscribers) fn(state);
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/services/state/ClientStateService.ts ---
// File: frontend/src/app/core/services/state/ClientStateService.ts

import type {
  ClientState,
  ClientStateServiceContract,
  Subscriber
} from '../../../types/index.js';

// ================================================== //
// ================================================== //

export class ClientStateService implements ClientStateServiceContract {
  static #instance: ClientStateService | null = null;

  #state: ClientState;
  #subscribers: Set<Subscriber<ClientState>>;

  // ------------------------------------------------ //

  private constructor(initial: ClientState) {
    this.#state = { ...initial };
    this.#subscribers = new Set();
  }

  // ------------------------------------------------ //

  static getInstance(initial: ClientState): ClientStateService {
    try {
      if (!ClientStateService.#instance) {
        ClientStateService.#instance = new ClientStateService(initial);
      }

      return ClientStateService.#instance;
    } catch (error) {
      throw new Error(
        `Failed to get ClientStateService instance: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  // ------------------------------------------------ //

  get(): ClientState {
    return { ...this.#state };
  }

  // ------------------------------------------------ //

  set(viewportWidth: number, viewportHeight: number): void {
    this.#state.viewportWidth = viewportWidth;
    this.#state.viewportHeight = viewportHeight;
    this.#notify();
  }

  // ------------------------------------------------ //

  subscribe(fn: Subscriber<ClientState>) {
    this.#subscribers.add(fn);
    fn(this.get());
    return () => this.#subscribers.delete(fn);
  }

  // ------------------------------------------------ //

  #notify(): void {
    const state = this.get();

    for (const fn of this.#subscribers) fn(state);
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/services/state/StateManager.ts ---
// File: frontend/src/app/core/services/state/StateManager.ts

import type {
  CanvasState,
  ClientState,
  Core,
  GifAnimation,
  State,
  StateLifecycleHook,
  StateManagerContract,
  Subscriber,
  TextElement,
  VisualLayer
} from '../../../types/index.js';
import { CanvasStateService, ClientStateService } from '../index.js';

// ================================================== //
// ================================================== //

export class StateManager implements StateManagerContract {
  static #instance: StateManager | null = null;

  #version: string | null = null;
  #lifecycleHooks: StateLifecycleHook[] = [];

  #canvas: CanvasStateService;
  #client: ClientStateService;

  #data: Core['data'];
  #errors: Core['services']['errors'];
  #log: Core['services']['log'];

  // ================================================= //

  private constructor(
    data: Core['data'],
    errors: Core['services']['errors'],
    log: Core['services']['log']
  ) {
    try {
      log.info('Initializing StateManager...', '[StateManager constructor]');

      this.#data = data;
      this.#errors = errors;
      this.#log = log;
      this.#version = data.version;

      // hydrate state
      let initialState: State = {
        version: this.#data.version,
        canvas: {
          width: this.#data.config.defaults.canvasWidth,
          height: this.#data.config.defaults.canvasHeight,
          layers: [],
          selectedLayerIndex: null
        },
        client: {
          viewportWidth: window.innerWidth,
          viewportHeight: window.innerHeight
        }
      };

      const saved = window.localStorage.getItem('appState');

      if (saved) {
        try {
          Object.assign(initialState, JSON.parse(saved));
          log.info(
            `StateManager hydrated from localStorage.`,
            '[StateManager constructor]'
          );
        } catch (error) {
          log.warn(
            'Failed to parse localStorage state. Using default values.',
            '[StateManager constructor]'
          );
        }
      }

      this.#canvas = CanvasStateService.getInstance(
        initialState.canvas,
        this.#data
      );
      this.#client = ClientStateService.getInstance(initialState.client);

      this.#canvas.subscribe(() => this.#persistToStorage());
      this.#client.subscribe(() => this.#persistToStorage());

      log.info(
        'StateManager initialized successfully.',
        '[StateManager constructor]'
      );
    } catch (error) {
      throw new Error(
        `Failed to initialize StateManager: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  // ================================================== //

  static getInstance(
    data: Core['data'],
    errors: Core['services']['errors'],
    log: Core['services']['log']
  ): StateManager {
    try {
      log.info('Calling StateManager.getInstance()...');

      if (!StateManager.#instance) {
        log.info(
          'No existing StateManager instance found. Creating new instance.'
        );
        return (StateManager.#instance = new StateManager(data, errors, log));
      }

      log.info('Returning existing StateManager instance.');
      return StateManager.#instance;
    } catch (error) {
      throw new Error(
        `Failed to get StateManager instance: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  // ================================================= //
  // CORE CLASS METHODS //

  addLifecycleHook(hook: StateLifecycleHook): void {
    this.#errors.handleSync(() => {
      this.#log.info(
        'Adding lifecycle hook.',
        'StateManager.addLifecycleHook()'
      );

      if (typeof hook !== 'function') {
        throw new Error('Lifecycle hook must be a function.');
      }

      this.#lifecycleHooks.push(hook);
      this.#log.info(
        'Lifecycle hook added successfully.',
        'StateManager.addLifecycleHook()'
      );
    }, 'Failed to add lifecycle hook.');
  }

  getState(): State {
    return this.#errors.handleSync(() => {
      this.#log.info('Returning current state.', 'StateManager.getState()');

      return {
        version: this.#version!,
        canvas: this.getCanvas(),
        client: this.getClient()
      };
    }, 'Failed to return state.');
  }

  // ================================================= //
  // PROXY CANVAS STATE ACCESS //

  addLayer(layer: VisualLayer): void {
    this.#canvas.addLayer(layer);
    for (const hook of this.#lifecycleHooks) {
      hook('addLayer', this.getCanvas());
    }
  }
  addTextElement(elem: TextElement): void {
    this.#canvas.addTextElement(elem);
  }
  canRedoCanvas(): boolean {
    return this.#canvas.canRedo();
  }
  canUndoCanvas(): boolean {
    return this.#canvas.canUndo();
  }
  clearCanvasAll(): void {
    this.#canvas.clearAll();
    window.localStorage.setItem('appState', JSON.stringify(this.getState()));
  }
  clearCanvasAnimation(): void {
    this.#canvas.clearAnimation();
  }
  getCanvas(): CanvasState {
    return this.#canvas.get();
  }
  getCanvasAspectRatio(): number | undefined {
    return this.#canvas.getAspectRatio();
  }
  moveLayer(index: number, newIndex: number): void {
    this.#canvas.moveLayer(index, newIndex);
  }
  moveTextElement(index: number, x: number, y: number): void {
    this.#canvas.moveTextElement(index, x, y);
  }
  redoCanvas(): void {
    this.#canvas.redo();
  }
  removeLayer(index: number): void {
    this.#canvas.removeLayer(index);
  }
  removeTextElement(index: number): void {
    this.#canvas.removeTextElement(index);
  }
  resetCanvas(): void {
    this.#canvas.reset();
  }
  setCanvas(width: number, height: number): void {
    this.#canvas.set(width, height);
  }
  setCanvasAnimation(anim: GifAnimation | null): void {
    this.#canvas.setAnimation(anim);
  }
  setCanvasAspectRatio(aspect: number | undefined): void {
    this.#canvas.setAspectRatio(aspect);
  }
  setCanvasImage(imageDataUrl: string | undefined): void {
    this.#canvas.setCanvasImage(imageDataUrl);
  }
  setSelectedLayerIndex(index: number | null): void {
    this.#canvas.setSelectedLayerIndex(index);
  }
  subscribeToCanvas(fn: Subscriber<CanvasState>): () => void {
    return this.#canvas.subscribe(fn);
  }
  undoCanvas(): void {
    this.#canvas.undo();
  }
  updateLayer(index: number, newLayer: VisualLayer): void {
    this.#canvas.updateLayer(index, newLayer);
  }
  updateTextElement(index: number, newElem: TextElement): void {
    this.#canvas.updateTextElement(index, newElem);
  }

  // ================================================= //
  // PROXY CLIENT STATE ACCESS //

  getClient(): ClientState {
    return this.#client.get();
  }
  setClient(viewportWidth: number, viewportHeight: number): void {
    this.#client.set(viewportWidth, viewportHeight);
  }
  subscribeToClient(fn: Subscriber<ClientState>): () => void {
    return this.#client.subscribe(fn);
  }

  // ================================================= //
  // PRIVATE METHODS //

  #persistToStorage(): void {
    return this.#errors.handleSync(() => {
      window.localStorage.setItem('appState', JSON.stringify(this.getState()));
    }, 'Failed to persist state to localStorage.');
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/services/storage/IDBStorageService.ts ---
// File: frotnend/src/app/core/services/storage/IDBStorageService.ts

import type { IStorageService } from '../../../types/index.js';

export class IDBStorageService implements IStorageService {
  static DB_NAME = 'graphix-app';
  static STORE = 'app-data';

  #db: IDBDatabase;

  private constructor(db: IDBDatabase) {
    this.#db = db;
  }

  // ======================================================= //

  static create(): Promise<IDBStorageService> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(IDBStorageService.DB_NAME, 1);
      request.onupgradeneeded = () => {
        const db = request.result;
        if (!db.objectStoreNames.contains(IDBStorageService.STORE)) {
          db.createObjectStore(IDBStorageService.STORE);
        }
      };
      request.onsuccess = () => {
        resolve(new IDBStorageService(request.result));
      };
      request.onerror = () => {
        reject(request.error);
      };
    });
  }

  // ======================================================= //

  clear(): Promise<void> {
    return new Promise((resolve, reject) => {
      const req = this.#tx('readwrite').clear();
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }

  get<T>(key: string): Promise<T | null> {
    return new Promise((resolve, reject) => {
      const req = this.#tx('readonly').get(key);
      req.onsuccess = () => resolve(req.result ? JSON.parse(req.result) : null);
      req.onerror = () => reject(req.error);
    });
  }

  remove(key: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const req = this.#tx('readwrite').delete(key);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }

  set<T>(key: string, value: T): Promise<void> {
    return new Promise((resolve, reject) => {
      const req = this.#tx('readwrite').put(JSON.stringify(value), key);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }

  // ======================================================= //

  #tx(mode: IDBTransactionMode): IDBObjectStore {
    return this.#db
      .transaction(IDBStorageService.STORE, mode)
      .objectStore(IDBStorageService.STORE);
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/services/storage/LocalStorageService.ts ---
// File: frontend/src/app/core/services/storage/LocalStorageService.ts

import type { IStorageService } from '../../../types/index.js';

// ========================================================= //
// ========================================================= //

export class LocalStorageService implements IStorageService {
  get<T>(key: string): Promise<T | null> {
    return Promise.resolve(
      localStorage.getItem(key) ? JSON.parse(localStorage.getItem(key)!) : null
    );
  }

  set<T>(key: string, value: T): Promise<void> {
    localStorage.setItem(key, JSON.stringify(value));
    return Promise.resolve();
  }

  remove(key: string): Promise<void> {
    localStorage.removeItem(key);
    return Promise.resolve();
  }

  clear(): Promise<void> {
    localStorage.clear();
    return Promise.resolve();
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/services/storage/StorageManager.ts ---
// File: frontend/src/app/core/services/storage/StorageManager.ts

import type { IStorageService } from '../../../types/index.js';
import { IDBStorageService } from './IDBStorageService.js';
import { LocalStorageService } from './LocalStorageService.js';

// ================================================== //
// ================================================== //

export class StorageManager implements IStorageService {
  static #instance: StorageManager | null = null;

  #backend: IStorageService;

  private constructor(backend: IStorageService) {
    this.#backend = backend;
  }

  static async getInstance(): Promise<StorageManager> {
    if (!StorageManager.#instance) {
      // try IndexedDB, fallback to LocalStorage
      let backend: IStorageService;

      try {
        backend = await IDBStorageService.create();
      } catch (e) {
        backend = new LocalStorageService();
      }

      StorageManager.#instance = new StorageManager(backend);
    }
    return StorageManager.#instance;
  }

  // ================================================ //

  get<T>(key: string): Promise<T | null> {
    return this.#backend.get<T>(key);
  }

  set<T>(key: string, value: T): Promise<void> {
    return this.#backend.set<T>(key, value);
  }

  remove(key: string): Promise<void> {
    return this.#backend.remove(key);
  }

  clear(): Promise<void> {
    return this.#backend.clear();
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/core/utils/canvas.ts ---
// File: frontend/src/app/core/utils/canvas.ts

import type {
  Helpers,
  CanvasUtils,
  Services,
  VisualLayer
} from '../../types/index.js';

export const canvasUtilityFactory = (): CanvasUtils => ({
  drawVisualLayersToContext(
    ctx: CanvasRenderingContext2D,
    layers: VisualLayer[],
    helpers: Helpers,
    log: Services['log']
  ): void {
    layers
      .slice()
      .sort((a, b) => a.zIndex - b.zIndex)
      .forEach(layer => {
        if (!layer.visible) return;

        ctx.save();

        // default blend mode
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = layer.opacity;

        // apply transform
        const x = layer.position?.x ?? 0;
        const y = layer.position?.y ?? 0;
        const scaleX = layer.scale?.x ?? 1;
        const scaleY = layer.scale?.y ?? 1;
        const rotation = layer.rotation?.currentAngle ?? 0;

        ctx.translate(x, y);
        ctx.rotate((rotation * Math.PI) / 180);
        ctx.scale(scaleX, scaleY);

        switch (layer.type) {
          case 'gif': {
            const frame = layer.gifFrames[layer.currentFrame];
            if (frame && frame.imageData instanceof ImageData) {
              ctx.putImageData(frame.imageData, 0, 0);
            } else {
              log.warn(`GIF frame not found or invalid for layer ${layer.id}`);
            }
            break;
          }
          case 'image': {
            if (
              layer.element &&
              layer.element.complete &&
              layer.element.naturalWidth > 0
            ) {
              ctx.drawImage(layer.element, 0, 0);
            }
            break;
          }

          case 'overlay': {
            ctx.globalCompositeOperation = helpers.canvas.mapBlendMode(
              layer.blendMode
            );
            ctx.drawImage(layer.element, 0, 0);
            break;
          }

          case 'sticker': {
            ctx.drawImage(layer.element, 0, 0);
            break;
          }

          case 'video': {
            ctx.drawImage(layer.element, 0, 0);
            break;
          }

          case 'text': {
            // no draw here — text layers are drawn in drawTextAndSelection()
            break;
          }
        }

        ctx.restore();
      });

    ctx.globalAlpha = 1.0;
    ctx.globalCompositeOperation = 'source-over';
  }
});

--- /home/viihna/Projects/graphix/frontend/src/app/core/utils/data.ts ---
// File: frontend/src/app/core/utils/data.ts

import type { DataUtils } from '../../types/index.js';

export const dataUtilityFactory = (): DataUtils => ({
  detectFileType(file: File): Promise<string | undefined> {
    const reader = new FileReader();

    return new Promise((resolve, reject) => {
      reader.onload = () => {
        const bytes = new Uint8Array(reader.result as ArrayBuffer);
        if (bytes[0] === 0x89 && bytes[1] === 0x50) return resolve('png');
        if (bytes[0] === 0xff && bytes[1] === 0xd8) return resolve('jpeg');
        if (bytes[0] === 0x47 && bytes[1] === 0x49) return resolve('gif');
        if (
          bytes[0] === 0x52 &&
          bytes[1] === 0x49 &&
          bytes[8] === 0x57 &&
          bytes[9] === 0x45
        )
          return resolve('webp');
        resolve(undefined);
      };
      reader.onerror = reject;
      reader.readAsArrayBuffer(file.slice(0, 16));
    });
  }
});

--- /home/viihna/Projects/graphix/frontend/src/app/core/utils/dom.ts ---
// File: frontend/src/app/core/utils/dom.ts

import { DomUtils } from '../../types/index.js';

// ================================================== //
// ================================================== //

export const domUtilityFactory = (): DomUtils => ({
  getCssVar(name: string): string {
    return getComputedStyle(document.documentElement)
      .getPropertyValue(name)
      .trim();
  }
});

--- /home/viihna/Projects/graphix/frontend/src/app/core/utils/math.ts ---
// File: frontend/src/app/core/utils/math.ts

import type { MathUtils } from '../../types/index.js';

export const mathUtilityFactory = (): MathUtils => ({
  modulo(x: number, n: number): number {
    return ((x % n) + n) % n;
  },

  roundToStep(x: number, step: number): number {
    return Math.round(x / step) * step;
  },

  toDegrees(rad: number): number {
    return rad * (180 / Math.PI);
  },

  toRadians(deg: number): number {
    return deg * (Math.PI / 180);
  }
});

--- /home/viihna/Projects/graphix/frontend/src/app/data/assets.ts ---
// File: frontend/src/app/core/data/assets.ts

import type {
  AssetData,
  AssetExts,
  AssetTags,
  SupportedExt,
  SupportedExts,
  UnsupportedExt,
  UnsupportedExts
} from '../types/index.js';

const supportedExts: SupportedExts = [
  'gif',
  'jpeg',
  'jpg',
  'png',
  'webp'
] as readonly SupportedExt[];

const unsupportedExts: UnsupportedExts = ['svg'] as readonly UnsupportedExt[];

const exts: AssetExts = {
  supported: supportedExts,
  unsupported: unsupportedExts
} as const;

export const tags: AssetTags = ['animation', 'custom', 'rotate'] as const;

// ================================================== //

export const assetsData: AssetData = {
  exts,
  tags
} as const;

--- /home/viihna/Projects/graphix/frontend/src/app/data/base.ts ---
// File: frontend/src/app/core/data/base.ts

import type { BaseData } from '../types/index.js';

const version = '0.0.1' as const;

export const baseData: BaseData = {
  version
} as const;

--- /home/viihna/Projects/graphix/frontend/src/app/data/config.ts ---
// File: frontend/src/app/core/data/config.ts

import type { ConfigData, Defaults, Paths, Regex } from '../types/index.js';

// ================================================== //

const defaultCanvasWidth: number = 800;
const defaultCanvasHeight: number = 600;
const defaultDebounceWait: number = 100;
const defaultFileName: string = 'something_broke';

const defaultAnimationFrameCount: number = 60;
const defaultFont: string = 'Arial';
const defaultTextColor = '#000000';
const defaultTextAlignment: CanvasTextAlign = 'center';
const defaultTextBaseline: CanvasTextBaseline = 'middle';

const defaultTextElement = {
  font: defaultFont,
  color: defaultTextColor,
  align: defaultTextAlignment,
  baseline: defaultTextBaseline
};

const defaults: Defaults = {
  animation: {
    frameCount: defaultAnimationFrameCount
  },
  canvasWidth: defaultCanvasWidth,
  canvasHeight: defaultCanvasHeight,
  debounceWait: defaultDebounceWait,
  fileName: defaultFileName,
  font: defaultFont,
  textAlignment: defaultTextAlignment,
  textBaseline: defaultTextBaseline,
  textColor: defaultTextColor,
  textElement: defaultTextElement
};

// ================================================== //

const paths: Paths = {
  gifWorkerScript: '/assets/scripts/gif.worker.js'
} as const;

// ================================================== //

const floatString: RegExp = /^[-+]?\d*\.\d+(e[-+]?\d+)?$/i;
const hex: RegExp = /^#(?:[0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/;
const integerString: RegExp = /^[-+]?\d+$/i;
const numberString: RegExp = /^[-+]?\d*\.?\d+(e[-+]?\d+)?$/i;

export const regex: Regex = {
  floatString,
  hex,
  integerString,
  numberString
} as const;

// =================================================== //

export const configData: ConfigData = {
  defaults,
  paths,
  regex
} as const;

--- /home/viihna/Projects/graphix/frontend/src/app/data/dom.ts ---
// File: frontend/src/app/core/data/dom.ts

import type {
  DomBtnIds,
  DomDivIds,
  DomClasses,
  DomData,
  DomFormIds,
  DomIds,
  DomInputIds
} from '../types/index.js';

// ================================================== //

const assetThumb = 'asset-thumbnail';
const fontSelector = 'font-selector';
const textEditOverlay = 'text-edit-overlay';
const textColorPicker = 'text-color-picker';
const textSizeInput = 'text-size-input';

const classes: DomClasses = {
  assetThumb,
  fontSelector,
  textColorPicker,
  textEditOverlay,
  textSizeInput
} as const;

// ================================================== //

const assetBrowserDiv = 'asset-browser';
const canvas = 'main-canvas';
const canvasContainerDiv = 'canvas-container';
const canvasToolbarDiv = 'canvas-toolbar';
const clearBtn = 'clear-btn';
const downloadBtn = 'download-btn';
const imgUploadInput = 'img-upload-input';
const textInput = 'text-input';
const textForm = 'text-form';
const toggleAssetBrowserBtn = 'toggle-asset-browser-btn';
const uploadBtn = 'upload-btn';

const btns: DomBtnIds = {
  clearBtn,
  downloadBtn,
  toggleAssetBrowserBtn,
  uploadBtn
} as const;

const divs: DomDivIds = {
  assetBrowserDiv,
  canvasContainerDiv: canvasContainerDiv,
  canvasToolbarDiv: canvasToolbarDiv
} as const;

const forms: DomFormIds = {
  textForm
} as const;

const inputs: DomInputIds = {
  imgUploadInput,
  textInput
} as const;

const domIDs: DomIds = {
  canvas,
  ...btns,
  ...divs,
  ...forms,
  ...inputs
} as const;

// ================================================== //

export const domData: DomData = {
  classes,
  ids: domIDs
} as const;

--- /home/viihna/Projects/graphix/frontend/src/app/data/flags.ts ---
// File: frontend/src/app/core/data/flags.ts

import type { Flags } from '../types/index.js';

export const flags: Flags = {
  devMode: true
} as const;

--- /home/viihna/Projects/graphix/frontend/src/app/data/index.ts ---
// File: frontend/src/app/data/index.ts

import type { Data } from '../types/index.js';
import { assetsData } from './assets.js';
import { baseData } from './base.js';
import { configData } from './config.js';
import { domData } from './dom.js';
import { flags } from './flags.js';
import { messageData } from './messages.js';

export const data: Data = {
  ...baseData,
  assets: assetsData,
  config: configData,
  dom: domData,
  flags: flags,
  msgs: messageData
} as const;

--- /home/viihna/Projects/graphix/frontend/src/app/data/messages.ts ---
// File: frontend/src/app/config/core/messages.ts

import type { ErrorMessages, MessageData } from '../types/index.js';

const unknownFatalError =
  'An unknown fatal error has occurred. Please refresh the page and try again. If the problem persists, please contact support.';

const errorMessages: ErrorMessages = {
  unknownFatalError
};

// ================================================== //

export const messageData: MessageData = {
  errors: errorMessages
} as const;

--- /home/viihna/Projects/graphix/frontend/src/app/features/engine/animation.ts ---
// File: frontend/src/app/features/engine/animation.ts

import { decompressFrames, parseGIF } from 'gifuct-js';
import type { GifAnimation, GifFrame } from '../../types/index.js';

export function createGifAnimation(arrayBuffer: ArrayBuffer): GifAnimation {
  const gif = parseGIF(arrayBuffer);
  const rawFrames = decompressFrames(gif, true);

  const frames: GifFrame[] = rawFrames.map(
    (frame): GifFrame => ({
      imageData: new ImageData(
        new Uint8ClampedArray(frame.patch), // ALWAYS convert to Uint8ClampedArray for ImageData
        frame.dims.width,
        frame.dims.height
      ),
      delay: (frame.delay || 10) * 10 // delay is in 0.01s; convert to ms
    })
  );

  let playing = false;
  let frameIndex = 0;
  let rafId: number | null = null;

  function isPlaying(): boolean {
    return playing;
  }

  function drawFrame(ctx: CanvasRenderingContext2D): void {
    const frame = frames[frameIndex];
    ctx.putImageData(frame.imageData, 0, 0);
  }

  function loop(ctx: CanvasRenderingContext2D, loopForever: boolean = true) {
    if (!playing) return;
    drawFrame(ctx);

    const nextDelay = frames[frameIndex].delay;
    frameIndex = (frameIndex + 1) % frames.length;

    if (frameIndex === 0 && !loopForever) {
      stop();
      return;
    }
    rafId = window.setTimeout(() => loop(ctx, loopForever), nextDelay);
  }

  function play(ctx: CanvasRenderingContext2D, loopForever = true) {
    if (playing) return;
    playing = true;
    frameIndex = 0;
    loop(ctx, loopForever);
  }

  function pause() {
    playing = false;
    if (rafId !== null) clearTimeout(rafId);
    rafId = null;
  }

  function stop() {
    pause();
    frameIndex = 0;
  }

  return { frames, isPlaying, play, pause, stop };
}

--- /home/viihna/Projects/graphix/frontend/src/app/features/engine/asset_browser.ts ---
// File: frontend/src/app/features/asset_browser.ts

import type {
  Core,
  GifAsset,
  ImageAsset,
  OverlayAsset,
  StickerAsset
} from '../../types/index.js';

function fileExtensionToVisualLayerType(
  core: Core,
  ext: string
): 'image' | 'gif' | 'overlay' | 'sticker' | 'text' | 'video' {
  switch (ext.toLowerCase()) {
    case 'jpg':
    case 'jpeg':
    case 'png':
    case 'webp':
      return 'image';

    case 'gif':
      return 'gif';

    case 'mp4':
    case 'webm':
      return 'video';
    default:
      core.services.log.warn(`Unsupported file extension: ${ext}`);
      return 'image';
  }
}

async function renderAssetBrowser(core: Core): Promise<void> {
  const {
    data: {
      dom: { classes, ids }
    },
    services: { log, stateManager }
  } = core;
  const browser = document.getElementById(ids.assetBrowserDiv);
  if (!browser) return;

  browser.innerHTML = '';

  const { loadAssetManifest } = await import('../../core/config/manifest.js');
  const { createLayer } = await import('./layers.js');

  const asset_manifest = await loadAssetManifest();

  asset_manifest.forEach(asset => {
    const thumb = document.createElement('img');
    thumb.src = asset.src;
    thumb.alt = asset.name;
    thumb.className = classes.assetBrowserThumb;

    thumb.addEventListener('click', () => {
      const fullAsset = {
        ...asset,
        size_kb: (asset as any).size_kb ?? 0,
        hash_sha256: (asset as any).hash_sha256 ?? '',
        extension: asset.extension ?? ''
      };

      let newLayer;

      switch (asset.class) {
        case 'animation':
          newLayer = createLayer.gif(
            fullAsset as GifAsset,
            stateManager.getCanvas().layers.length
          );
          break;

        case 'image':
          newLayer = createLayer.image(
            fullAsset as ImageAsset,
            stateManager.getCanvas().layers.length
          );
          break;

        case 'overlay':
          newLayer = createLayer.overlay(
            fullAsset as OverlayAsset,
            stateManager.getCanvas().layers.length
          );
          break;

        case 'sticker':
          newLayer = createLayer.sticker(
            fullAsset as StickerAsset,
            stateManager.getCanvas().layers.length
          );
          break;

        default:
          log.warn(`Unsupported asset class: ${asset.class}`);
          newLayer = createLayer.image(
            fullAsset as ImageAsset,
            stateManager.getCanvas().layers.length
          );
      }

      stateManager.addLayer(newLayer);
    });
  });
}

export { fileExtensionToVisualLayerType, renderAssetBrowser };

--- /home/viihna/Projects/graphix/frontend/src/app/features/engine/io.ts ---
// File: frontend/src/app/features/engine/io.ts

import type {
  Core,
  GifAnimation,
  IOFunctions,
  SupportedExt,
  VisualLayer
} from '../../types/index.js';
import GIF from 'gif.js';
import html2canvas from 'html2canvas';

async function exportGif(
  layers: VisualLayer[],
  width: number,
  height: number,
  frameCount: number = 60,
  core: Core,
  fileName?: string
): Promise<void> {
  const {
    data: {
      config: { defaults, paths }
    }
  } = core;
  if (!fileName) fileName = defaults.fileName + '.gif';

  return new Promise((resolve, reject) => {
    const gif = new GIF({
      workers: 2,
      quality: 10,
      width,
      height,
      workerScript: paths.gifWorkerScript
    });

    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = width;
    offscreenCanvas.height = height;

    const offCtx = offscreenCanvas.getContext('2d');
    if (!offCtx) {
      reject(new Error('Offscreen canvas 2D context unavailable'));
      return;
    }

    const baseFrameDelay = 100; // ms/frame

    for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
      // step GIF layers to this frame
      for (const layer of layers) {
        if (layer.type === 'gif') {
          layer.currentFrame = frameIndex % layer.gifFrames.length;
        }
      }

      // draw this frame
      offCtx.clearRect(0, 0, width, height);
      // drawVisualLayersToContext(offCtx, layers);

      // add frame to GIF
      gif.addFrame(offCtx, { copy: true, delay: baseFrameDelay });
    }

    gif.on('finished', (blob: Blob) => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
      resolve();
    });

    (gif as any).on('error', (error: unknown) => {
      reject(error);
    });

    gif.render();
  });
}

async function exportStaticFile(
  layers: VisualLayer[],
  width: number,
  height: number,
  core: Core,
  fileName?: string
): Promise<void> {
  const {
    data: {
      config: { defaults }
    },
    helpers,
    services: { errors },
    utils
  } = core;
  if (!fileName) fileName = defaults.fileName + '.png';

  return errors.handleAsync(async () => {
    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = width;
    offscreenCanvas.height = height;

    const offCtx = offscreenCanvas.getContext('2d');
    if (!offCtx) throw new Error('Offscreen canvas 2D context unavailable');

    offCtx.clearRect(0, 0, width, height);

    // draw all layers
    utils.canvas.drawVisualLayersToContext(offCtx, layers, helpers);

    // export as PNG
    offscreenCanvas.toBlob(blob => {
      if (!blob) throw new Error('Failed to generate PNG blob');

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
    }, 'image/png');
  }, 'Static file export failed.');
}

async function handleDownload(
  targetRef: React.RefObject<HTMLDivElement | null>,
  core: Core,
  fileName?: string
): Promise<void> {
  const {
    data: {
      config: { defaults }
    },
    services: { errors, log }
  } = core;
  if (!fileName) fileName = defaults.fileName;

  return errors.handleAsync(async () => {
    if (!targetRef.current) {
      log.error('Target reference is null or undefined.', 'handleDownload');
      return;
    }

    const canvas = await html2canvas(targetRef.current, {
      backgroundColor: null
    });
    const url = canvas.toDataURL('image/png');
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;
    link.click();
  }, 'File download failed.');
}

async function handleUpload(
  file: File,
  core: Core,
  createGifAnimation: (arrayBuffer: ArrayBuffer) => GifAnimation
): Promise<void> {
  const {
    data: {
      dom: { ids }
    },
    helpers,
    services: { cache, errors, stateManager }
  } = core;

  return errors.handleAsync(async () => {
    const fileName = file.name;
    const ext = fileName.split('.').pop()?.toLowerCase() ?? '';

    const canvas = document.getElementById(
      ids.canvas
    ) as HTMLCanvasElement | null;
    if (!canvas) throw new Error(`Canvas element not found.`);

    const ctx = helpers.canvas.get2DContext(canvas);

    // GIF support
    if (ext === ('gif' as SupportedExt)) {
      const arrayBuffer = await file.arrayBuffer();
      const anim = createGifAnimation(arrayBuffer);

      stateManager.setCanvasAnimation(anim);

      anim.play(ctx);

      // don't run static image logic!
      return;
    }

    const reader = new FileReader();
    reader.onload = (e: ProgressEvent<FileReader>) => {
      const img = new Image();

      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);

        const imgAspect = img.width / img.height;
        const imageDataUrl = e.target?.result as string;

        stateManager.setCanvasImage(imageDataUrl);
        stateManager.setCanvasAspectRatio(imgAspect);

        cache.cachedBgImg = img;

        canvas.style.width = 'auto';
        canvas.style.height = 'auto';

        const canvasAspect = canvas.width / canvas.height;
        let drawWidth, drawHeight, offsetX, offsetY;
        if (imgAspect > canvasAspect) {
          drawWidth = canvas.width;
          drawHeight = canvas.width / imgAspect;
          offsetX = 0;
          offsetY = (canvas.height - drawHeight) / 2;
        } else {
          drawHeight = canvas.height;
          drawWidth = canvas.height * imgAspect;
          offsetY = 0;
          offsetX = (canvas.width - drawWidth) / 2;
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      };
      img.src = e.target?.result as string;
    };
    reader.readAsDataURL(file);
  }, 'File upload processing failed.');
}

// =================================================== //

export const io: IOFunctions = {
  exportGif,
  exportStaticFile,
  handleDownload,
  handleUpload
} as const;

--- /home/viihna/Projects/graphix/frontend/src/app/features/engine/layers.ts ---
// File: frontend/src/app/features/engine/layers.ts

import {
  GifAsset,
  GifVisualLayer,
  ImageAsset,
  ImageVisualLayer,
  OverlayAsset,
  OverlayVisualLayer,
  StickerAsset,
  StickerVisualLayer,
  TextElement,
  TextVisualLayer
} from '../../types/index.js';

// ====================================================== //

function makeGifLayer(asset: GifAsset, zIndex: number): GifVisualLayer {
  return {
    id: crypto.randomUUID(),
    type: 'gif',
    assetRef: asset,
    opacity: 1,
    visible: true,
    zIndex,
    gifFrames: [],
    currentFrame: 0,
    frameElapsed: 0
  };
}

function makeImageLayer(asset: ImageAsset, zIndex: number): ImageVisualLayer {
  return {
    id: crypto.randomUUID(),
    type: 'image',
    assetRef: asset,
    opacity: 1,
    visible: true,
    zIndex,
    element: new Image()
  };
}

function makeOverlayLayer(
  asset: OverlayAsset,
  zIndex: number
): OverlayVisualLayer {
  return {
    id: crypto.randomUUID(),
    type: 'overlay',
    assetRef: asset,
    opacity: 1,
    visible: true,
    zIndex,
    blendMode: asset.blendMode,
    element: new Image()
  };
}

function makeStickerLayer(
  asset: StickerAsset,
  zIndex: number
): StickerVisualLayer {
  return {
    id: crypto.randomUUID(),
    type: 'sticker',
    assetRef: asset,
    opacity: 1,
    visible: true,
    zIndex,
    element: new Image()
  };
}

function makeTextLayer(
  zIndex: number,
  elements: TextElement[]
): TextVisualLayer {
  return {
    id: crypto.randomUUID(),
    type: 'text',
    assetRef: null,
    opacity: 1,
    visible: true,
    zIndex,
    textElements: elements
  };
}

// ====================================================== //

export const createLayer = {
  gif: makeGifLayer,
  image: makeImageLayer,
  overlay: makeOverlayLayer,
  sticker: makeStickerLayer,
  text: makeTextLayer
} as const;

--- /home/viihna/Projects/graphix/frontend/src/app/features/engine/overlays.ts ---
// FileL frontend/src/app/features/engine/overlays.ts

import type { Core, OverlayFunctions, TextElement } from '../../types/index.js';

function removeExistingOverlay(className: string): void {
  document.querySelectorAll(`.${className}`).forEach(e => e.remove());
}

function showTextElementOverlay(
  canvas: HTMLCanvasElement,
  elem: TextElement,
  index: number,
  core: Core,
  redraw: () => void
): void {
  const {
    data: {
      dom: { classes }
    },
    services: { stateManager }
  } = core;
  const className = classes.textEditOverlay;

  removeExistingOverlay(className);

  // canvas/text position calc
  const rect = canvas.getBoundingClientRect();
  const ctx = canvas.getContext('2d')!;
  ctx.font = `${elem.fontWeight ?? 'bold'} ${elem.fontSize ?? 32}px ${elem.fontFamily ?? 'sans-serif'}`;
  const width = ctx.measureText(elem.text).width + 16;
  const height = (elem.fontSize ?? 32) + 8;
  const x = rect.left + elem.x * (rect.width / canvas.width) - width / 2;
  const y = rect.top + elem.y * (rect.height / canvas.height) - height / 2;

  // overlay
  const overlay = document.createElement('div');
  overlay.className = className;
  Object.assign(overlay.style, {
    position: 'absolute',
    left: `${x}px`,
    top: `${y + height + 10}px`, // below the text
    zIndex: '10000',
    padding: '12px',
    background: 'rgba(255,255,255,0.97)',
    border: '1.5px solid #b4b4b4',
    borderRadius: '8px',
    boxShadow: '0 2px 14px #0003',
    minWidth: '220px'
  });

  // text input
  const textInput = document.createElement('input');
  textInput.type = 'text';
  textInput.value = elem.text;
  textInput.style.width = '100%';

  // font select
  const fontSelect = document.createElement('select');
  fontSelect.className = classes.fontSelector;
  ['Arial', 'Impact', 'Comic Sans MS', 'Times New Roman'].forEach(f => {
    const opt = document.createElement('option');
    opt.value = f;
    opt.text = f;
    if (elem.fontFamily === f) opt.selected = true;
    fontSelect.appendChild(opt);
  });

  // size input
  const sizeInput = document.createElement('input');
  sizeInput.type = 'number';
  sizeInput.min = '8';
  sizeInput.max = '200';
  sizeInput.value = String(elem.fontSize);

  // color input
  const colorInput = document.createElement('input');
  colorInput.type = 'color';
  colorInput.value = elem.color;

  // save/cancel buttons
  const saveBtn = document.createElement('button');
  saveBtn.innerText = 'Done';
  saveBtn.type = 'button';
  const cancelBtn = document.createElement('button');
  cancelBtn.innerText = 'Cancel';
  cancelBtn.type = 'button';
  cancelBtn.style.marginLeft = '8px';

  // form layout
  overlay.append(
    'Text:',
    document.createElement('br'),
    textInput,
    document.createElement('br'),
    'Font:',
    document.createElement('br'),
    fontSelect,
    document.createElement('br'),
    'Size:',
    document.createElement('br'),
    sizeInput,
    document.createElement('br'),
    'Color:',
    document.createElement('br'),
    colorInput,
    document.createElement('br'),
    saveBtn,
    cancelBtn
  );

  // commit logic
  function commitEdit() {
    stateManager.updateTextElement(index, {
      ...elem,
      text: textInput.value,
      fontFamily: fontSelect.value,
      fontSize: parseInt(sizeInput.value, 10),
      color: colorInput.value as TextElement['color']
    });
    overlay.remove();
    redraw();
  }
  // cancellation logic
  function cancelEdit() {
    overlay.remove();
    redraw();
  }

  saveBtn.addEventListener('click', commitEdit);
  cancelBtn.addEventListener('click', cancelEdit);
  overlay.addEventListener('keydown', (e: KeyboardEvent) => {
    if (e.key === 'Escape') cancelEdit();
    if (e.key === 'Enter') commitEdit();
  });

  // focus logic
  setTimeout(() => textInput.focus(), 20);

  // attach to DOM
  document.body.appendChild(overlay);
}

// ================================================== //

export const overlayFns: OverlayFunctions = {
  removeExistingOverlay,
  showTxtElemOverlay: showTextElementOverlay
} as const;

--- /home/viihna/Projects/graphix/frontend/src/app/features/engine/RenderingEngine.ts ---
// File: frontend/src/app/features/engine/RenderingEngine.ts

import type {
  CanvasResizeOptions,
  CanvasState,
  Core,
  ImageVisualLayer,
  RedrawPlugin,
  RenderingEngineContract,
  TextVisualLayer,
  VisualLayer
} from '../../types/index.js';

// ====================================================== //
// ====================================================== //

export class RenderingEngine implements RenderingEngineContract {
  static #instance: RenderingEngine | null = null;

  #data: Core['data'];
  #devMode: Core['data']['flags']['devMode'];
  #redrawPlugins: RedrawPlugin[] = [];

  #ctx: CanvasRenderingContext2D | null = null;

  #core: Core;
  #errors: Core['services']['errors'];
  #helpers: Core['helpers'];
  #log: Core['services']['log'];
  #stateManager: Core['services']['stateManager'];
  #utils: Core['utils'];

  // ==================================================== //

  private constructor(ctx: CanvasRenderingContext2D, core: Core) {
    const {
      data,
      helpers,
      services: { errors, log, stateManager },
      utils
    } = core;

    this.#ctx = ctx;

    this.#core = core;

    this.#data = data;
    this.#helpers = helpers;
    this.#utils = utils;

    this.#devMode = data.flags.devMode;
    this.#errors = errors;
    this.#log = log;
    this.#stateManager = stateManager;

    this.#stateManager.subscribeToCanvas(() => {
      this.render();
    });
  }

  // ==================================================== //

  static getInstance(
    ctx: CanvasRenderingContext2D,
    core: Core
  ): RenderingEngine {
    const { errors, log } = core.services;
    return errors.handleSync(() => {
      log.info(`RENDERING_ENGINE: calling getInstance()...`);

      if (!RenderingEngine.#instance) {
        log.info(
          `RENDERING_ENGINE: No existing instance found. Creating new instance.`
        );
        RenderingEngine.#instance = new RenderingEngine(ctx, core);
      }

      return RenderingEngine.#instance;
    }, 'RENDERING_ENGINE: Failed to get instance.');
  }

  // ==================================================== //

  render(state: CanvasState = this.#stateManager.getCanvas()): void {
    return this.#errors.handleSync(() => {
      // 1. clear the canvas
      this.clearCanvas(this.#ctx!);

      // 2. draw dev overlays
      if (this.#devMode) this.drawDevOverlay();

      // 3. draw main boundary
      this.drawBoundary(this.#ctx!);

      // 4. draw all layers (z-index, blend mode, etc.)
      if (state.layers.length > 0) {
        this.#utils.canvas.drawVisualLayersToContext(
          this.#ctx!,
          state.layers,
          this.#helpers
        );
      }
      // 5. draw text and selection overlays
      this.#drawTextAndSelection(
        this.#ctx!,
        state.layers,
        state.selectedLayerIndex
      );

      // 6. run redraw plugins
      for (const plugin of this.#redrawPlugins) {
        plugin(this.#ctx!, this.#core);
      }
    }, 'RENDERING_ENGINE: Failed to render canvas.');
  }

  // ==================================================== //

  addRedrawPlugin(plugin: RedrawPlugin): void {
    return this.#errors.handleSync(() => {
      this.#redrawPlugins.push(plugin);
    }, 'RENDERING_ENGINE: Failed to add redraw plugin.');
  }

  attachImageOnLoadHandler(layer: ImageVisualLayer): void {
    if (layer.element && !layer.element.complete) {
      this.render();
    }
  }

  autoResize({
    canvas,
    container,
    preserveAspectRatio = true
  }: CanvasResizeOptions): () => void {
    return this.#errors.handleSync(() => {
      const resize = () => {
        const rect = container.getBoundingClientRect();

        if (preserveAspectRatio) {
          const aspect = canvas.width / canvas.height || 4 / 3;
          let width = rect.width;
          let height = rect.width / aspect;

          if (height > rect.height) {
            height = rect.height;
            width = rect.height * aspect;
          }

          canvas.style.width = `${width}px`;
          canvas.style.height = `${height}px`;
        } else {
          canvas.style.width = `${rect.width}px`;
          canvas.style.height = `${rect.height}px`;
        }
      };

      resize(); // initial resize call

      window.addEventListener('resize', resize);

      return () => window.removeEventListener('resize', resize);
    }, 'Unhandled canvas auto-resize error.');
  }

  clearCanvas(ctx: CanvasRenderingContext2D): void {
    return this.#errors.handleSync(() => {
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    }, 'RENDERING_ENGINE: Unhandled canvas clear error.');
  }

  drawBoundary(ctx: CanvasRenderingContext2D): void {
    return this.#errors.handleSync(() => {
      ctx.save();
      ctx.lineWidth = 8;
      ctx.strokeStyle = '#ff80c5ff';
      ctx.setLineDash([12, 10]);
      ctx.strokeRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.restore();
    }, 'Unhandled canvas boundary drawing error.');
  }

  drawDevOverlay(): void {
    return this.#errors.handleSync(() => {
      // draw crosshairs (or whatever dev markers I want)
      this.#ctx!.save();
      this.#ctx!.strokeStyle = 'rgba(255,0,0,0.25)';
      this.#ctx!.lineWidth = 1;
      this.#ctx!.setLineDash([4, 4]);
      this.#ctx!.beginPath();
      this.#ctx!.moveTo(0, this.#ctx!.canvas.height / 2);
      this.#ctx!.lineTo(this.#ctx!.canvas.width, this.#ctx!.canvas.height / 2);
      this.#ctx!.moveTo(this.#ctx!.canvas.width / 2, 0);
      this.#ctx!.lineTo(this.#ctx!.canvas.width / 2, this.#ctx!.canvas.height);
      this.#ctx!.stroke();
      this.#ctx!.restore();
    }, 'RENDERING_ENGINE: Failed to draw dev overlay.');
  }

  redraw(ctx: CanvasRenderingContext2D, state: CanvasState): void {
    return this.#errors.handleSync(() => {
      this.clearCanvas(ctx);
      this.drawBoundary(ctx);
      this.#utils.canvas.drawVisualLayersToContext(
        ctx,
        state.layers,
        this.#helpers
      );
      this.#drawTextAndSelection(ctx, state.layers, state.selectedLayerIndex);
    }, 'Unhandled canvas redraw error.');
  }

  removeRedrawPlugin(plugin: RedrawPlugin): void {
    return this.#errors.handleSync(() => {
      this.#redrawPlugins = this.#redrawPlugins.filter(fn => fn !== plugin);
    }, 'RENDERING_ENGINE: Failed to remove redraw plugin.');
  }

  renderTo(ctx: CanvasRenderingContext2D, state?: CanvasState): void {
    return this.#errors.handleSync(() => {
      const prev = this.#devMode;
      const origCtx = this.#ctx;
      this.#ctx = ctx;
      this.render(state);
      this.#ctx = origCtx;
      this.#devMode = prev;
    }, 'RENDERING_ENGINE: Failed to render to provided context.');
  }

  resizeCanvasToParent(): void {
    return this.#errors.handleSync(() => {
      const canvas = document.getElementById(
        this.#data.dom.ids.canvas
      ) as HTMLCanvasElement | null;
      if (!canvas) throw new Error('Canvas element not found!');
      const parent = canvas.parentElement;
      if (!parent) throw new Error('Canvas has no parent element!');

      const rect = parent.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      // set actual bitmap size
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);

      // set display size
      canvas.style.width = `${rect.width}px`;
      canvas.style.height = `${rect.height}px`;
    }, 'Unhandled canvas resize error.');
  }

  // ==================================================== //
  // PRIVATE METHODS //

  #drawTextAndSelection(
    ctx: CanvasRenderingContext2D,
    layers: VisualLayer[],
    selectedLayerIndex: number | null
  ): void {
    return this.#errors.handleSync(() => {
      const textLayer = layers.find(
        (l): l is TextVisualLayer => l.type === 'text'
      );

      if (!textLayer) return;

      for (const elem of textLayer.textElements!) {
        ctx.save();
        const fontSize = elem.fontSize ?? 32;
        const fontWeight = elem.fontWeight ?? 'bold';
        const fontFamily = elem.fontFamily ?? 'sans-serif';
        ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
        ctx.fillStyle = elem.color;
        ctx.textAlign = elem.align;
        ctx.textBaseline = elem.baseline;
        ctx.fillText(elem.text, elem.x, elem.y);
        ctx.restore();
      }

      if (selectedLayerIndex !== null) {
        const selectedLayer = layers[selectedLayerIndex];
        if (selectedLayer?.type === 'text') {
          ctx.save();
          ctx.strokeStyle = '#00F6';
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 2]);
          ctx.strokeRect(0, 0, ctx.canvas.width, ctx.canvas.height);
          ctx.restore();
        }
      }
    }, 'Unhandled canvas text and selection drawing error.');
  }

  // ==================================================== //

  _(): void {
    this.#data = this.#data;
    this.#errors = this.#errors;
    this.#helpers = this.#helpers;
    this.#log = this.#log;
    this.#utils = this.#utils;
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/features/engine/start.ts ---
// File: frontend/src/app/features/engine/start.ts

import type {
  Core,
  IOFunctions,
  OverlayFunctions,
  TextVisualLayer
} from '../../types/index.js';
import { RenderingEngine } from '../../features/engine/RenderingEngine.js';

let selectedTextIndex: number | null = null;
let dragging = false;
let dragOffset = { x: 0, y: 0 };
let isResizing = false;
let resizeTargetIndex: number | null = null;
let initialMouseY = 0;
let initialFontSize = 32;

function initAssetBrowserToggleBtn(core: Core): void {
  const {
    data: {
      dom: { ids }
    }
  } = core;
  const toggleBtn = document.getElementById(
    ids.toggleAssetBrowserBtn
  ) as HTMLButtonElement | null;
  const browser = document.getElementById(
    ids.assetBrowserDiv
  ) as HTMLDivElement | null;

  if (!toggleBtn) throw new Error(`Asset Browser Toggle Button not found!`);
  if (!browser) throw new Error(`Asset Browser Div not found!`);

  toggleBtn.addEventListener('click', () => {
    browser.classList.toggle('open');
  });

  document.addEventListener('click', (e: MouseEvent) => {
    if (!browser.contains(e.target as Node) && e.target !== toggleBtn) {
      browser.classList.remove('open');
    }
  });
}

function initClearBtn(core: Core): void {
  const {
    data: {
      dom: { ids }
    },
    services: { cache, errors, log, stateManager }
  } = core;

  return errors.handleSync(() => {
    const clearBtnId = ids.clearBtn;
    const btn = document.getElementById(clearBtnId) as HTMLButtonElement | null;

    if (!btn) throw new Error(`Canvas Clear Button not found!`);

    btn.addEventListener('click', () => {
      // 1. remove all text elements
      stateManager.clearCanvasAll();

      // 2. remove background image from state
      stateManager.setCanvasImage(undefined);
      stateManager.setCanvasAspectRatio(undefined);

      // 3. clear animations
      stateManager.clearCanvasAnimation();

      // 4. clear cached background image
      cache.cachedBgImg = null;
      const canvas = document.getElementById(
        ids.canvas
      ) as HTMLCanvasElement | null;
      if (!canvas) {
        throw new Error(`Canvas element not found in DOM!`);
      }
      stateManager.clearCanvasAll();

      log.info(
        `Canvas cleared and reset via StateManager.`,
        'initializeCanvasClearButton'
      );
    });

    log.debug(`Clear Button listener successfully attached.`);
  }, 'Unhandled Canvas Clear Button initialization error.');
}

// --------------------------------------------------- //

function initDownloadBtn(core: Core, io: IOFunctions): void {
  const {
    data: {
      dom: { ids },
      config: { defaults }
    },
    helpers,
    services: { errors, log, stateManager }
  } = core;

  return errors.handleSync(() => {
    const btnId = ids.downloadBtn;
    const btn = document.getElementById(btnId) as HTMLButtonElement | null;

    if (!btn) throw new Error(`Download button not found!`);

    btn.addEventListener('click', () => {
      const canvas = document.getElementById(
        ids.canvas
      ) as HTMLCanvasElement | null;
      if (!canvas) {
        throw new Error(`Canvas element not found in DOM!`);
      }
      const ctx = helpers.canvas.get2DContext(canvas);

      if (!ctx) {
        throw new Error(`Canvas 2D context not available.`);
        return;
      }

      const state = stateManager.getCanvas();
      const hasAnimatedLayer = state.layers.some(layer => layer.type === 'gif');

      const width = canvas.width;
      const height = canvas.height;
      const frameCount = defaults.animation.frameCount;
      const fileName = defaults.fileName || 'default.png';

      if (hasAnimatedLayer) {
        log.info(`AnimationLayer(s) detected - running GIF export pipeline...`);
        io.exportGif(state.layers, width, height, frameCount, core, fileName);
      } else {
        log.info(`Running static image export pipeline...`);
        io.exportStaticFile(state.layers, width, height, core, fileName);
      }
    });

    log.debug(`Download Button listener successfully attached.`);
  }, 'Unhandled Download Button initialization error.');
}

// --------------------------------------------------- //

function initTextInputForm(core: Core): void {
  const {
    data: {
      dom: { ids }
    },
    services: { errors, stateManager }
  } = core;

  return errors.handleSync(() => {
    const textForm = document.getElementById(
      ids.textForm
    ) as HTMLFormElement | null;
    const textInput = document.getElementById(
      ids.textInput
    ) as HTMLInputElement | null;

    if (!textForm) {
      throw new Error(`Text form not found in DOM.`);
    }
    if (!textInput) {
      throw new Error(`Text input not found in DOM.`);
    }

    // grab the canvas/context
    const canvas = document.getElementById(
      ids.canvas
    ) as HTMLCanvasElement | null;
    if (!canvas) {
      throw new Error(`Canvas element not found in DOM!`);
    }

    textForm.addEventListener('submit', (e: Event) => {
      e.preventDefault();

      const text = textInput.value.trim();
      if (!text) return;

      stateManager.addTextElement({
        text,
        x: canvas.width / 2,
        y: canvas.height / 2,
        font: 'bold 32px sans-serif',
        fontSize: 32,
        color: '#000000',
        align: 'center',
        baseline: 'middle'
      });

      textInput.value = '';
    });
  }, 'Unhandled Text Input Form initialization error.');
}

// --------------------------------------------------- //

async function initUploadBtn(core: Core, io: IOFunctions): Promise<void> {
  const {
    data: {
      dom: { ids }
    },
    services
  } = core;
  const { errors } = services;
  const { createGifAnimation } = await import('./animation.js');

  return errors.handleAsync(async () => {
    const uploadBtn = document.getElementById(
      ids.uploadBtn
    ) as HTMLButtonElement | null;
    const imgInput = document.getElementById(
      ids.imgUploadInput
    ) as HTMLInputElement | null;

    if (!uploadBtn) throw new Error('Upload button not found.');
    if (!imgInput) throw new Error('Image upload input not found.');

    // button click opens file dialog
    uploadBtn.addEventListener('click', () => imgInput.click());

    // file select triggers upload logic
    imgInput.addEventListener('change', () => {
      const file = imgInput.files?.[0];
      if (!file) return;

      io.handleUpload(file, core, createGifAnimation);
    });
  }, 'Failed to initialize upload UI.');
}

// --------------------------------------------------- //

function setupTextDragHandlers(
  canvas: HTMLCanvasElement,
  overlay: OverlayFunctions,
  core: Core,
  renderingEngine: RenderingEngine
): void {
  const { helpers, services } = core;
  const { errors, stateManager } = services;

  return errors.handleSync(() => {
    canvas.addEventListener('mousedown', (e: MouseEvent) => {
      dragging = false;
      isResizing = false;
      selectedTextIndex = null;
      resizeTargetIndex = null;

      const state = stateManager.getState();
      const mouse = helpers.canvas.getMousePosition(canvas, e);
      const ctx = canvas.getContext('2d')!;

      const textLayer = state.canvas.layers.find(
        (layer): layer is TextVisualLayer => layer.type === 'text'
      );

      if (!textLayer) return;

      for (let i = textLayer.textElements.length - 1; i >= 0; i--) {
        const elem = textLayer.textElements[i];

        if (helpers.canvas.isOverResizeHandle(mouse, elem, ctx)) {
          isResizing = true;
          resizeTargetIndex = i;
          initialMouseY = mouse.y;
          initialFontSize = elem.fontSize ?? 32;
          stateManager.setSelectedLayerIndex(i);

          return;
        }

        if (helpers.canvas.isPointInText(mouse, elem, ctx)) {
          selectedTextIndex = i;
          dragging = true;
          dragOffset.x = mouse.x - elem.x;
          dragOffset.y = mouse.y - elem.y;
          stateManager.setSelectedLayerIndex(i);
          break;
        }
      }
    });

    canvas.addEventListener('mousemove', (e: MouseEvent) => {
      const ctx = canvas.getContext('2d')!;
      const state = stateManager.getCanvas();

      const textLayer = state.layers.find(layer => layer.type === 'text') as
        | TextVisualLayer
        | undefined;

      if (!textLayer) return;

      if (isResizing && resizeTargetIndex !== null) {
        const elem = textLayer.textElements[resizeTargetIndex];
        const mouse = helpers.canvas.getMousePosition(canvas, e);
        const deltaY = mouse.y - initialMouseY;
        const newFontSize = Math.max(10, initialFontSize + deltaY);

        // update element
        const updatedElem = { ...elem, fontSize: newFontSize };
        textLayer.textElements[resizeTargetIndex] = updatedElem;

        renderingEngine.redraw(ctx, stateManager.getCanvas());
        return;
      }

      if (dragging && selectedTextIndex !== null) {
        const elem = textLayer.textElements[selectedTextIndex];
        const mouse = helpers.canvas.getMousePosition(canvas, e);

        const updatedElem = {
          ...elem,
          x: mouse.x - dragOffset.x,
          y: mouse.y - dragOffset.y
        };
        textLayer.textElements[selectedTextIndex] = updatedElem;

        renderingEngine.redraw(ctx, stateManager.getCanvas());
      }
    });

    canvas.addEventListener('mouseup', () => {
      dragging = false;
      isResizing = false;
      resizeTargetIndex = null;
    });

    canvas.addEventListener('mouseleave', () => {
      dragging = false;
      isResizing = false;
      resizeTargetIndex = null;
    });

    canvas.addEventListener('dblclick', (e: MouseEvent) => {
      const state = stateManager.getCanvas();
      const mouse = helpers.canvas.getMousePosition(canvas, e);

      const textLayer = state.layers.find(layer => layer.type === 'text') as
        | TextVisualLayer
        | undefined;

      if (!textLayer) return;

      for (let i = textLayer.textElements.length - 1; i >= 0; i--) {
        const elem = textLayer.textElements[i];

        if (
          helpers.canvas.isPointInText(mouse, elem, canvas.getContext('2d')!)
        ) {
          overlay.showTxtElemOverlay(canvas, elem, i, core, () =>
            renderingEngine.redraw(
              canvas.getContext('2d')!,
              stateManager.getCanvas()
            )
          );

          break;
        }
      }
    });
  }, 'Unhandled text drag handlers initialization error.');
}

// =================================================== //

export async function initializeCanvasUI(
  io: IOFunctions,
  overlay: OverlayFunctions,
  core: Core,
  renderingEngine: RenderingEngine
): Promise<void> {
  const {
    data: {
      dom: { ids }
    },
    services: { errors }
  } = core;
  const canvas = document.getElementById(
    ids.canvas
  ) as HTMLCanvasElement | null;

  if (!canvas) {
    throw new Error(`Canvas element not found in DOM!`);
  }

  return errors.handleAsync(async () => {
    initAssetBrowserToggleBtn(core);
    initClearBtn(core);
    initDownloadBtn(core, io);
    await initUploadBtn(core, io);
    initTextInputForm(core);
    setupTextDragHandlers(canvas, overlay, core, renderingEngine);
  }, 'Canvas UI initialization failed.');
}

--- /home/viihna/Projects/graphix/frontend/src/app/main.ts ---
// File: frontend/src/app/main.ts

import('./sys/events/dom.js').then(({ onDOMContentLoaded }) => {
  onDOMContentLoaded(async () => {
    try {
      const { launchApp } = await import('./sys/launch.js');
      const {
        core: {
          data: {
            dom: { ids }
          }
        }
      } = await launchApp();

      const canvas = document.getElementById(
        ids.canvas
      ) as HTMLCanvasElement | null;

      if (!canvas) throw new Error('Canvas element not found in DOM!');

      const ctx = canvas.getContext('2d');
      if (!ctx) throw new Error('2D context not available for canvas!');
    } catch (error) {
      console.error(
        `An unhandled error occurred during application startup:`,
        error instanceof Error ? error.message : error
      );
      throw new Error(`Startup failed.`);
    }
  });
});

export {};

--- /home/viihna/Projects/graphix/frontend/src/app/sys/bootstrap.ts ---
// File: frontend/src/app/sys/bootstrap.ts

import type { Core } from '../types/index.js';

async function setGlobalErrorHandlers(core: Core): Promise<void> {
  const {
    services: { log }
  } = core;

  log.info(`Registering global error handlers`);

  try {
    window.onerror = function (message, source, lineno, colno, error) {
      console.log(
        `Unhandled error: ${message} at ${source}:${lineno}:${colno}`
      );
      if (error && error.stack) {
        console.log(`Stack trace:\n${error.stack}`);
      }
      return false;
    };
    window.addEventListener('unhandledrejection', event => {
      console.log(`Unhandled promise rejection: ${event.reason}`);
    });
  } catch (error) {
    log.error(
      `Failed to register global error handlers:`,
      error instanceof Error ? error.message : String(error)
    );
    throw new Error(`Global error handler registration failed.`);
  }
}

// ================================================== //

export async function bootstrap(core: Core): Promise<void> {
  await setGlobalErrorHandlers(core);
}

--- /home/viihna/Projects/graphix/frontend/src/app/sys/events/dom.ts ---
// File: frontend/src/app/sys/events/dom.ts

// ================================================== //
// ================================================== //

export function onDOMContentLoaded(cb: () => void): void {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', cb);
  } else {
    cb();
  }
}

// ================================================== //

export function onResize(cb: () => void): void {
  window.addEventListener('resize', cb);
}

--- /home/viihna/Projects/graphix/frontend/src/app/sys/initialize.ts ---
// File: frontend/src/app/sys/initialize.ts

import type {
  Core,
  Data,
  Helpers,
  Services,
  Utilities
} from '../types/index.js';
import { RenderingEngine } from '../features/engine/RenderingEngine.js';

export async function initializeData(): Promise<Required<Data>> {
  console.log(`Initializing Data object...`);

  try {
    const { data } = await import('../data/index.js');

    return data;
  } catch (error) {
    console.error(`Failed to initialize Data:`, error);
    throw new Error(`Data initialization failed`);
  }
}

async function initializeHelpers(): Promise<Required<Helpers>> {
  console.log(`Initializing Helpers object...`);

  try {
    const { helpersFactory } = await import('../core/factories/helpers.js');

    const helpers: Helpers = await helpersFactory();

    return helpers;
  } catch (error) {
    console.error(`Failed to initialize Helpers:`, error);
    throw new Error(`Helpers initialization failed`);
  }
}

async function initializeServices(
  data: Data,
  helpers: Helpers
): Promise<Required<Services>> {
  console.log(`Initializing Services object...`);

  try {
    const { serviceFactory } = await import('../core/factories/services.js');

    const services: Services = await serviceFactory(data, helpers);

    return services;
  } catch (error) {
    console.error(`Failed to initialize Services:`, error);
    throw new Error(`Services initialization failed`);
  }
}

async function initializeUtilities(
  services: Services
): Promise<Required<Utilities>> {
  console.log(`Initializing Utilities object...`);

  return await services.errors.handleAsync(async () => {
    const { utilitiesFactory } = await import('../core/factories/utilities.js');
    const utilities: Utilities = await utilitiesFactory(services);

    return utilities;
  }, `Utilities initialization failed.`);
}

// ================================================== //

export async function initializeCore(): Promise<Core> {
  console.log(`Starting dependency initialization...`);

  let core = {} as Core;

  const data = await initializeData();
  core.data = data;

  const helpers = await initializeHelpers();
  core.helpers = helpers;

  const services = await initializeServices(data, helpers);
  core.services = services;

  const utils = await initializeUtilities(services);
  core.utils = utils;

  const log = services.log;
  log.info(`All dependencies initialized successfully.`);

  return core;
}

export async function initializeRenderingEngine(
  ctx: CanvasRenderingContext2D,
  core: Core
): Promise<RenderingEngine> {
  const {
    services: { errors, log }
  } = core;

  return errors.handleAsync(async () => {
    log.info('Initializing the Rendering Engine...');
    const renderingEngine = RenderingEngine.getInstance(ctx, core);
    return renderingEngine;
  }, `Rendering Engine initialization failed.`);
}

export async function initializeUI(core: Core): Promise<RenderingEngine> {
  const {
    data: {
      dom: { ids }
    },
    services
  } = core;
  const { errors } = services;

  return errors.handleAsync(async () => {
    const canvas = document.getElementById(
      ids.canvas
    ) as HTMLCanvasElement | null;
    if (!canvas) throw new Error(`Canvas element not found in DOM!`);
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error(`2D context not available for canvas!`);
    const container = document.getElementById(ids.canvasContainerDiv);
    if (!container) throw new Error(`Canvas container not found in DOM!`);

    const canvasRefs = { canvas, ctx };
    const renderingEngine = await initializeRenderingEngine(ctx, core);

    const { io } = await import('../features/engine/io.js');
    const { overlayFns: overlay } = await import(
      '../features/engine/overlays.js'
    );
    const { initializeCanvasUI } = await import('../features/engine/start.js');

    await initializeCanvasUI(io, overlay, core, renderingEngine);

    renderingEngine.autoResize({
      canvas,
      container,
      preserveAspectRatio: true
    });

    window.addEventListener('resize', () => {
      errors.handleSync(() => {
        renderingEngine.resizeCanvasToParent();
        renderingEngine.clearCanvas(canvasRefs.ctx);
        renderingEngine.drawBoundary(canvasRefs.ctx);
      }, 'Canvas resize/redraw failed');
    });

    return renderingEngine;
  }, `UI initialization failed.`);
}

--- /home/viihna/Projects/graphix/frontend/src/app/sys/launch.ts ---
// File: frontend/src/app/sys/launch.ts

import type { Core } from '../types/index.js';
import { RenderingEngine } from '../features/engine/RenderingEngine.js';

export async function launchApp(): Promise<{
  core: Core;
  renderingEngine: RenderingEngine;
}> {
  try {
    console.log(`Launching application...`);

    // 1. Load Static Data
    console.log(`Loading static Data object...`);
    const { initializeData } = await import('./initialize.js');
    const data = await initializeData();
    console.log(
      `Successfully loaded static Data object: ${JSON.stringify(data, null, 2)}`
    );

    // 2. Initialize App Core
    console.log(`Initializing App Core...`);
    const { initializeCore } = await import('./initialize.js');
    const core = await initializeCore();
    const {
      services: { log }
    } = core;
    log.info(
      `Successfully initialized the Application Core.`,
      JSON.stringify(core, null, 2)
    );

    // 3. Global One-Off Setup (error handlers, etc.)
    log.info(`Executing bootstrap processes...`);
    const { bootstrap } = await import('./bootstrap.js');
    await bootstrap(core);
    log.info(`Bootstrap processes completed successfully.`);

    // 4. Register Event Listeners
    log.info(`Registering event listeners...`);
    const { eventListeners, registerEventListeners } = await import(
      './registries/events.js'
    );
    registerEventListeners(eventListeners, core);
    log.info(`Event listeners registered successfully.`);

    // 5. Register Plugins
    log.info(`Registering plugins...`);
    const { plugins } = await import('./registries/plugins.js');
    for (const plugin of plugins) await plugin.register(core);
    log.info(`Plugins registered successfully.`);

    // 6. Initialize User Interface
    log.info(`Initializing User Interface...`);
    const { initializeUI } = await import('./initialize.js');
    await initializeUI(core);
    log.info(`User Interface initialized successfully.`);

    // 7. Initialize Rendering Engine
    log.info(`Initializing Rendering Engine...`);
    const { initializeRenderingEngine } = await import('./initialize.js');
    const ctx = document.querySelector('canvas')?.getContext('2d');
    if (!ctx) {
      throw new Error(`Failed to get 2D context from canvas element.`);
    }
    const renderingEngine = await initializeRenderingEngine(ctx, core);

    // 8. Initialise Asset Browser Rendering SubEngine
    log.info(`Initializing Asset Browser Rendering SubEngine...`);
    const { renderAssetBrowser } = await import(
      '../features/engine/asset_browser.js'
    );
    await renderAssetBrowser(core).then(() =>
      log.info(`Asset Browser Rendering SubEngine initialized successfully.`)
    );

    return {
      core,
      renderingEngine
    };
  } catch (error) {
    console.error(
      `An unknown error occurred during application startup:`,
      error
    );
    throw new Error(`Application startup failed.`);
  }
}

--- /home/viihna/Projects/graphix/frontend/src/app/sys/registries/events.ts ---
// File: frontend/src/app/sys/registries/events.ts

import type { Core, ListenerRegistration } from '../../types/index.js';

export const eventListeners: ListenerRegistration[] = [
  (core: Core) => {
    const {
      services: { errors, log, stateManager }
    } = core;
    errors.handleSync(() => {
      log.info(
        'Registering global event listeners...',
        'registries > events > eventListeners'
      );

      window.addEventListener('resize', () => {
        // TODO: resize handler logic here
      });

      window.addEventListener('keydown', (event: KeyboardEvent) => {
        if (
          event.key === 'Delete' &&
          stateManager.getCanvas().selectedLayerIndex !== null
        ) {
          const idx = stateManager.getCanvas().selectedLayerIndex!;
          stateManager.removeTextElement(idx);
          stateManager.getCanvas().selectedLayerIndex = null;
          log.info(
            `Deleted text element at index: ${idx}`,
            'event:keydown:Delete'
          );
        }
      });
    }, 'Unhandled error during event listener registration.');
  }
];

// ================================================== //

export function registerEventListeners(
  listeners: ListenerRegistration[],
  core: Core
): void {
  const {
    data: { msgs },
    services: { errors }
  } = core;
  const errorMsgs = msgs.errors;

  errors.handleAsync(
    async () => {
      listeners.forEach(listener => listener(core));
    },
    'An unknown error occurred while registering event listeners.',
    {
      context: 'application startup',
      fallback: 'n/a',
      userMessage: errorMsgs.unknownFatalError
    }
  );
}

--- /home/viihna/Projects/graphix/frontend/src/app/sys/registries/plugins.ts ---
// File: frontend/src/app/sys/registries/plugins.ts

import type { Plugin } from '../../types/index.js';

export const plugins: Plugin[] = [];

// ================================================== //

export function registerPlugin(_plugin: Plugin): void {}

--- /home/viihna/Projects/graphix/frontend/src/app/sys/registries/ui.ts ---
// File: frontend/src/app/sys/registries/ui.ts

import type { UIInitializer } from '../../types/index.js';

// ================================================== //

export const uiInitializers: UIInitializer[] = [];

--- /home/viihna/Projects/graphix/frontend/src/app/types/app/assets.ts ---
// File: frontend/src/app/types/assets.ts

import { VisualLayer } from './index.js';

export interface AnimationGroup {
  id: string;
  layers: VisualLayer[];
  isPlaying: boolean;
  playbackRate: number;
}

export interface AnimationProps {
  frames: {
    count: number;
    rate: number; // fps
  };
  rotation?: {
    speed: 360; // degrees per second
    direction: 'clockwise' | 'counter-clockwise' | 'n/a';
  };
}

export type AssetClass = 'animation' | 'image' | 'text';

export type AssetManifestEntry =
  | BackgroundAsset
  | BorderAsset
  | FontAsset
  | GifAsset
  | ImageAsset
  | OverlayAsset
  | StickerAsset;

export interface BaseAsset {
  name: string;
  src: string /* path relative to assets/ */;
  size_kb: number;
  hash_sha256: string;
  class: string;
  extension: string;
  tags?: string[];
  credit?: string;
  license?: string;
}

export interface BackgroundAsset extends BaseAsset {
  tileable: boolean;
}

export interface BorderAsset extends BaseAsset {
  animated: boolean;
  width: number;
  shape: 'circle' | 'square' | 'rounded' | 'other';
}

export interface FontAsset extends BaseAsset {
  fontFamily: string;
  serif: boolean;
  style?: string;
  weight?: number | string;
}

export interface GifAsset extends BaseAsset {
  animation?: AnimationProps;
}

export interface ImageAsset extends BaseAsset {}

export interface OverlayAsset extends BaseAsset {
  blendMode?:
    | 'normal'
    | 'multiply'
    | 'screen'
    | 'overlay'
    | 'darken'
    | 'lighten'
    | 'color-dodge'
    | 'color-burn'
    | 'hard-light'
    | 'soft-light'
    | 'difference'
    | 'exclusion';
}

export interface StickerAsset extends BaseAsset {}

export type SupportedAsset =
  | ImageAsset
  | GifAsset
  | OverlayAsset
  | StickerAsset;

--- /home/viihna/Projects/graphix/frontend/src/app/types/app/cache.ts ---
// File: frontend/src/app/types/app/cache.ts

export interface Cache {
  bgImg: HTMLImageElement | null;
}

--- /home/viihna/Projects/graphix/frontend/src/app/types/app/core.ts ---
// File: frontend/src/application/types/app/core.ts

import type { Core } from '../index.js';

export interface Cache {
  bgImg: HTMLImageElement | null;
}

export interface CanvasResizeOptions {
  canvas: HTMLCanvasElement;
  container: HTMLElement;
  preserveAspectRatio?: boolean;
}

export interface ErrorHandlerOptions {
  context?: Record<string, unknown> | string;
  fallback?: unknown;
  userMessage?: string;
}

export type ListenerRegistration = (core: Core) => void | (() => void);

export type NotifierLevel = 'info' | 'warn' | 'error' | 'success';

export interface Plugin {
  id: string;
  register: (core: Core) => void | Promise<void>;
}

export type RedrawPlugin = (ctx: CanvasRenderingContext2D, core: Core) => void;

export type ResizePlugin = () => void;

export type Subscriber<T> = (state: T) => void;

export interface TextElement {
  text: string;
  x: number;
  y: number;
  align: CanvasTextAlign;
  baseline: CanvasTextBaseline;
  color: string;
  font: string;
  fontFamily?: string;
  fontSize: number;
  fontWeight?: string;
  rotation?: number;
  scale?: number;
}

export type UIInitializer = (core: Core) => void | Promise<void>;

--- /home/viihna/Projects/graphix/frontend/src/app/types/app/engine.ts ---
// File: frontend/src/app/types/app/engine.ts

import type { CanvasState } from '../index.js';

export type CanvasLifecycleEvent =
  | 'addLayer'
  | 'removeLayer'
  | 'undo'
  | 'redo'
  | 'clear';

export type StateLifecycleHook = (
  event: CanvasLifecycleEvent,
  state: CanvasState
) => void;

--- /home/viihna/Projects/graphix/frontend/src/app/types/app/index.ts ---
// File: frontend/src/app/types/app/index.ts

export type {
  AnimationGroup,
  AnimationProps,
  AssetClass,
  AssetManifestEntry,
  BaseAsset,
  BackgroundAsset,
  BorderAsset,
  FontAsset,
  GifAsset,
  ImageAsset,
  OverlayAsset,
  StickerAsset,
  SupportedAsset
} from './assets.js';
export type {
  Cache,
  CanvasResizeOptions,
  ErrorHandlerOptions,
  ListenerRegistration,
  NotifierLevel,
  Plugin,
  RedrawPlugin,
  ResizePlugin,
  Subscriber,
  TextElement,
  UIInitializer
} from './core.js';
export type { CanvasLifecycleEvent, StateLifecycleHook } from './engine.js';
export type {
  BaseVisualLayer,
  GifAnimation,
  GifFrame,
  GifVisualLayer,
  ImageVisualLayer,
  OverlayVisualLayer,
  StickerVisualLayer,
  TextVisualLayer,
  VideoVisualLayer,
  VisualLayer
} from './layers.js';
export type { CanvasState, ClientState, State } from './state.js';

--- /home/viihna/Projects/graphix/frontend/src/app/types/app/layers.ts ---
// File: frontend/src/app/types/layers.ts

import type {
  AnimationProps,
  OverlayAsset,
  SupportedAsset,
  TextElement
} from '../index.js';

export interface BaseVisualLayer {
  id: string;
  type: string;
  assetRef: SupportedAsset | null;
  opacity: number;
  visible: boolean;
  zIndex: number;
  position?: { x: number; y: number };
  rotation?: {
    speed: number;
    direction: 'clockwise' | 'counter-clockwise' | 'n/a';
    currentAngle: number;
  };
  scale?: { x: number; y: number };
}

export interface GifAnimation {
  frames: GifFrame[];
  isPlaying: () => boolean;
  pause: () => void;
  play: (ctx: CanvasRenderingContext2D, loop?: boolean) => void;
  stop: () => void;
}

export interface GifFrame {
  imageData: ImageData;
  delay: number; // in ms
}

export interface GifVisualLayer extends BaseVisualLayer {
  type: 'gif';
  animationProps?: AnimationProps;
  gifFrames: GifFrame[];
  currentFrame: number;
  frameElapsed: number;
}

export interface ImageVisualLayer extends BaseVisualLayer {
  type: 'image';
  element: HTMLImageElement;
}

export interface OverlayVisualLayer extends BaseVisualLayer {
  type: 'overlay';
  blendMode?: OverlayAsset['blendMode'];
  element: HTMLImageElement | HTMLCanvasElement;
}

export interface StickerVisualLayer extends BaseVisualLayer {
  type: 'sticker';
  element: HTMLImageElement | HTMLCanvasElement;
}

export interface TextVisualLayer extends BaseVisualLayer {
  type: 'text';
  textElements: TextElement[];
}

export interface VideoVisualLayer extends BaseVisualLayer {
  type: 'video';
  element: HTMLVideoElement;
}

export type VisualLayer =
  | ImageVisualLayer
  | GifVisualLayer
  | OverlayVisualLayer
  | StickerVisualLayer
  | TextVisualLayer
  | VideoVisualLayer;

--- /home/viihna/Projects/graphix/frontend/src/app/types/app/state.ts ---
// File: frontend/src/app/types/app/state.ts

import type { VisualLayer } from './layers.js';

export type CanvasState = {
  width: number;
  height: number;
  layers: VisualLayer[];
  selectedLayerIndex: number | null;
  aspectRatio?: number | undefined;
};

export interface ClientState {
  viewportWidth: number;
  viewportHeight: number;
}

export interface State {
  version: string;
  canvas: CanvasState;
  client: ClientState;
}

--- /home/viihna/Projects/graphix/frontend/src/app/types/contracts.ts ---
// File: frontend/src/app/types/contracts.ts

import type {
  AnimationGroup,
  CanvasState,
  ClientState,
  ErrorHandlerOptions,
  GifAnimation,
  NotifierLevel,
  RedrawPlugin,
  ResizePlugin,
  State,
  StateLifecycleHook,
  Subscriber,
  TextElement,
  VisualLayer
} from './index.js';

// ================================================== //
// ================================================== //
// ================================================== //

export interface AnimationGroupManagerContract {
  addGroup: (group: AnimationGroup) => void;
  removeGroup: (groupId: string) => void;
  pause: (groupId: string) => void;
  play: (groupId: string) => void;
  update(deltaTime: number): void;
}

export interface CacheManagerContract {
  clearAll(): void;
}

export interface ErrorHandlerServiceContract {
  handleAndReturn<T>(
    action: () => T | Promise<T>,
    errorMessage: string,
    options?: ErrorHandlerOptions
  ): T | Promise<T>;
  handleAsync<T>(
    action: () => Promise<T>,
    errorMessage: string,
    options?: ErrorHandlerOptions
  ): Promise<T>;
  handleSync<T>(
    action: () => T,
    errorMessage: string,
    options?: ErrorHandlerOptions
  ): T;
}

export interface LoggerServiceContract {
  debug: (message: string, caller?: string) => void;
  error: (message: string, caller?: string) => void;
  info: (message: string, caller?: string) => void;
  warn: (message: string, caller?: string) => void;
}

export interface NotifierServiceContract {
  notify: (message: string, level: NotifierLevel) => void;
  info: (message: string) => void;
  warn: (message: string) => void;
  error: (message: string) => void;
  success: (message: string) => void;
}

export interface ResizeManagerContract {
  initialize: () => void;
  register: (plugin: ResizePlugin) => void;
  runAll: () => void;
  unregister: (plugin: ResizePlugin) => void;
}

// ================================================== //
// ================================================== //
// ================================================== //

export interface StateManagerContract {
  addLayer(layer: VisualLayer): void;
  addLifecycleHook(hook: StateLifecycleHook): void;
  addTextElement(elem: TextElement): void;
  canRedoCanvas: () => boolean;
  canUndoCanvas: () => boolean;
  clearCanvasAll(): void;
  clearCanvasAnimation: () => void;
  getCanvas: () => CanvasState;
  getCanvasAspectRatio: () => number | undefined;
  getClient: () => ClientState;
  getState: () => State;
  moveLayer: (index: number, newIndex: number) => void;
  moveTextElement: (index: number, x: number, y: number) => void;
  removeLayer: (index: number) => void;
  resetCanvas: () => void;
  setCanvas: (width: number, height: number) => void;
  setCanvasAnimation: (anim: GifAnimation | null) => void;
  setCanvasAspectRatio: (aspect: number) => void;
  setCanvasImage: (imageDataUrl: string | undefined) => void;
  setClient: (viewportWidth: number, viewportHeight: number) => void;
  setSelectedLayerIndex: (index: number | null) => void;
  subscribeToCanvas: (fn: Subscriber<CanvasState>) => () => void;
  subscribeToClient: (fn: Subscriber<ClientState>) => () => void;
  redoCanvas: () => void;
  undoCanvas: () => void;
  updateLayer: (index: number, newLayer: VisualLayer) => void;
  updateTextElement: (index: number, newElem: TextElement) => void;
}

export interface CanvasStateServiceContract {
  addLayer(layer: VisualLayer): void;
  addTextElement: (elem: TextElement) => void;
  canRedo: () => boolean;
  canUndo: () => boolean;
  clearAll: () => void;
  clearAnimation: () => void;
  get: () => CanvasState;
  getAspectRatio: () => number | undefined;
  getLayers(): VisualLayer[];
  getSelectedLayerIndex(): number | null;
  moveLayer(index: number, newIndex: number): void;
  moveTextElement: (index: number, x: number, y: number) => void;
  redo: () => void;
  removeLayer(index: number): void;
  removeTextElement: (index: number) => void;
  reset: () => void;
  set: (width: number, height: number) => void;
  setAnimation: (anim: GifAnimation) => void;
  setAspectRatio: (aspect: number) => void;
  setCanvasImage: (imageDataUrl: string | undefined) => void;
  setSelectedLayerIndex(index: number | null): void;
  subscribe: (fn: Subscriber<CanvasState>) => () => void;
  undo: () => void;
  updateLayer(index: number, newLayer: VisualLayer): void;
  updateTextElement: (index: number, newElem: TextElement) => void;
}

export interface ClientStateServiceContract {
  get: () => ClientState;
  set: (viewportWidth: number, viewportHeight: number) => void;
  subscribe: (fn: Subscriber<ClientState>) => () => void;
}

// ================================================== //
// ================================================== //
// ================================================== //

export interface IStorageService {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T): Promise<void>;
  remove(key: string): Promise<void>;
  clear(): Promise<void>;
}

// ================================================== //
// ================================================== //
// ================================================== //

export interface RenderingEngineContract {
  addRedrawPlugin: (plugin: RedrawPlugin) => void;
  drawDevOverlay: () => void;
  render: (state?: CanvasState) => void;
  removeRedrawPlugin: (plugin: RedrawPlugin) => void;
  renderTo: (ctx: CanvasRenderingContext2D, state?: CanvasState) => void;
}

--- /home/viihna/Projects/graphix/frontend/src/app/types/css.ts ---
// File: frontend/src/app/types/css.ts/

export type TextUnit = 'em' | 'pt' | 'px' | 'rem';

export interface TextStyle {
  font: {
    align?: 'left' | 'center' | 'right' | 'justify';
    baseline?: 'middle' | 'top' | 'bottom';
    color?: string;
    family?: string;
    size?: {
      value: number;
      unit: TextUnit;
    };
    weight?: 'normal' | 'bold';
  };
}

export interface Styles {
  text: TextStyle[];
}

--- /home/viihna/Projects/graphix/frontend/src/app/types/data.ts ---
// File: frontend/src/app/types/data.ts

import type { AssetClass } from './index.js';

export interface AssetData {
  exts: AssetExts;
  tags: AssetTags;
}

export interface AssetExts {
  supported: SupportedExts;
  unsupported: UnsupportedExts;
}

export type AssetManifest = {
  name: string;
  class: AssetClass;
  ext: string;
  type: string;
  src: string;
}[];

export type AssetTags = string[];

export interface BaseData {
  version: string;
}

export interface ConfigData {
  defaults: Defaults;
  paths: Paths;
  regex: Regex;
}

export interface Defaults {
  animation: {
    frameCount: number;
  };
  canvasWidth: number;
  canvasHeight: number;
  debounceWait: number;
  fileName: string;
  font: string;
  textAlignment: CanvasTextAlign;
  textBaseline: CanvasTextBaseline;
  textColor: string;
  textElement: {
    font: string;
    color: string;
    align: CanvasTextAlign;
    baseline: CanvasTextBaseline;
  };
}

export interface DomDivIds {
  assetBrowserDiv: string;
  canvasContainerDiv: string;
  canvasToolbarDiv: string;
}

export interface DomBtnIds {
  clearBtn: string;
  downloadBtn: string;
  toggleAssetBrowserBtn: string;
  uploadBtn: string;
}

export type DomClasses = Record<string, string>;

export interface DomData {
  classes: DomClasses;
  ids: DomIds;
}

export interface DomFormIds {
  textForm: string;
}

export type DomIds = DomBtnIds &
  DomDivIds &
  DomFormIds &
  DomInputIds & {
    canvas: string;
  };

export interface DomInputIds {
  imgUploadInput: string;
  textInput: string;
}

export interface ErrorMessages {
  unknownFatalError: string;
}

export interface Flags {
  devMode: boolean;
}

export interface Manifests {
  asset: AssetManifest;
}

export interface MessageData {
  errors: ErrorMessages;
}

export interface Paths {
  gifWorkerScript: '/assets/scripts/gif.worker.js';
}

export interface Regex {
  floatString: RegExp;
  hex: RegExp;
  integerString: RegExp;
  numberString: RegExp;
}

export type SupportedExt = 'gif' | 'jpeg' | 'jpg' | 'png' | 'webp';

export type SupportedExts = Readonly<SupportedExt[]>;

export type UnsupportedExt = 'svg';

export type UnsupportedExts = Readonly<UnsupportedExt[]>;

// ================================================== //

export interface Data extends BaseData {
  assets: AssetData;
  config: ConfigData;
  dom: DomData;
  flags: Flags;
  msgs: MessageData;
}

--- /home/viihna/Projects/graphix/frontend/src/app/types/functions.ts ---
// File: frontend/src/app/types/functions.ts

import type { Data, GifAnimation, TextElement, VisualLayer } from './index.js';
import {
  AnimationGroupManager,
  CacheManager,
  ErrorHandler,
  Logger,
  ResizeManager,
  StateManager,
  StorageManager
} from '../core/services/index.js';

// ================================================== //
// ========= CORE FUNCTION OBJECTS ================== //
// ================================================== //

export interface Core {
  data: Required<Data>;
  helpers: Required<Helpers>;
  services: Required<Services>;
  utils: Required<Utilities>;
}

export interface Helpers {
  app: AppHelpers;
  canvas: CanvasHelpers;
  data: DataHelpers;
  math: MathHelpers;
  time: TimeHelpers;
}

export type Services = {
  animationGroupManager: AnimationGroupManager;
  cache: CacheManager;
  errors: ErrorHandler;
  log: Logger;
  resizeManager: ResizeManager;
  stateManager: StateManager;
  storageManager: StorageManager;
};

export interface Utilities {
  canvas: CanvasUtils;
  data: DataUtils;
  dom: DomUtils;
  math: MathUtils;
}

// ================================================== //
// ======= CORE FUNCTION OBJECT PARTIALS ============ //
// ================================================== //

export interface AppHelpers {
  noop: () => void;
}

export interface CanvasHelpers {
  get2DContext: (canvas: HTMLCanvasElement) => CanvasRenderingContext2D;
  getMousePosition(
    canvas: HTMLCanvasElement,
    evt: MouseEvent
  ): {
    x: number;
    y: number;
  };
  isOverResizeHandle(
    mouse: { x: number; y: number },
    elem: TextElement,
    ctx: CanvasRenderingContext2D
  ): boolean;
  isPointInText(
    pt: { x: number; y: number },
    elem: TextElement,
    ctx: CanvasRenderingContext2D
  ): boolean;
  mapBlendMode: (blendMode?: string) => GlobalCompositeOperation;
}

export interface DataHelpers {
  clone: <T>(data: T) => T;
  getFileSizeInKB: (file: File | Blob) => number;
  getFileSHA256: (file: File | Blob) => Promise<string>;
}
export interface MathHelpers {
  weightedRandom: (min: number, max: number, weight: number) => number;
}

export interface TimeHelpers {
  debounce: <T extends (...args: Record<string, unknown>[]) => void>(
    fn: T,
    wait?: number
  ) => (...args: Parameters<T>) => void;
}

export interface CanvasUtils {
  drawVisualLayersToContext(
    ctx: CanvasRenderingContext2D,
    layers: VisualLayer[],
    helpers: Helpers,
    log: Services['log']
  ): void;
}

export interface DataUtils {
  detectFileType: (file: File) => Promise<string | undefined>;
}

export interface DomUtils {
  getCssVar: (name: string) => string;
}

export interface MathUtils {
  modulo: (x: number, n: number) => number;
  roundToStep: (x: number, step: number) => number;
  toDegrees: (rad: number) => number;
  toRadians: (deg: number) => number;
}

// ================================================== //

export interface IOFunctions {
  exportGif: (
    layers: VisualLayer[],
    width: number,
    height: number,
    frameCount: number,
    core: Core,
    fileName?: string
  ) => Promise<void>;
  exportStaticFile: (
    layers: VisualLayer[],
    width: number,
    height: number,
    core: Core,
    fileName?: string
  ) => Promise<void>;
  handleDownload(
    targetRef: React.RefObject<HTMLDivElement | null>,
    core: Core,
    fileName?: string
  ): Promise<void>;
  handleUpload: (
    file: File,
    core: Core,
    createGifAnimation: (arrayBuffer: ArrayBuffer) => GifAnimation
  ) => Promise<void>;
}

export interface OverlayFunctions {
  removeExistingOverlay(className: string): void;
  showTxtElemOverlay: (
    canvas: HTMLCanvasElement,
    elem: TextElement,
    index: number,
    core: Core,
    redraw: () => void
  ) => void;
}

--- /home/viihna/Projects/graphix/frontend/src/app/types/generics.ts ---
// File: frontend/src/app/types/generics.ts

export type Brand<T, B extends string> = T & { __brand: B };

--- /home/viihna/Projects/graphix/frontend/src/app/types/index.ts ---
// File: frontend/src/app/types/index.ts

export type {
  AnimationGroup,
  AnimationProps,
  AssetClass,
  AssetManifestEntry,
  BackgroundAsset,
  BaseAsset,
  BaseVisualLayer,
  BorderAsset,
  Cache,
  CanvasLifecycleEvent,
  CanvasResizeOptions,
  CanvasState,
  ClientState,
  ErrorHandlerOptions,
  FontAsset,
  GifAnimation,
  GifAsset,
  GifFrame,
  GifVisualLayer,
  ImageAsset,
  ImageVisualLayer,
  ListenerRegistration,
  NotifierLevel,
  OverlayAsset,
  OverlayVisualLayer,
  Plugin,
  RedrawPlugin,
  ResizePlugin,
  State,
  StateLifecycleHook,
  StickerAsset,
  StickerVisualLayer,
  Subscriber,
  SupportedAsset,
  TextElement,
  TextVisualLayer,
  UIInitializer,
  VideoVisualLayer,
  VisualLayer
} from './app/index.js';
export type {
  AnimationGroupManagerContract,
  CacheManagerContract,
  CanvasStateServiceContract,
  ClientStateServiceContract,
  ErrorHandlerServiceContract,
  IStorageService,
  NotifierServiceContract,
  LoggerServiceContract,
  RenderingEngineContract,
  ResizeManagerContract,
  StateManagerContract
} from './contracts.js';
export type { TextStyle } from './css.js';
export type {
  AssetData,
  AssetExts,
  AssetManifest,
  AssetTags,
  BaseData,
  ConfigData,
  Data,
  Defaults,
  DomBtnIds,
  DomData,
  DomClasses,
  DomDivIds,
  DomFormIds,
  DomIds,
  DomInputIds,
  ErrorMessages,
  Flags,
  MessageData,
  Paths,
  Regex,
  SupportedExt,
  SupportedExts,
  UnsupportedExt,
  UnsupportedExts
} from './data.js';
export type {
  AppHelpers,
  CanvasHelpers,
  CanvasUtils,
  Core,
  DataHelpers,
  DataUtils,
  DomUtils,
  Helpers,
  IOFunctions,
  MathHelpers,
  MathUtils,
  OverlayFunctions,
  Services,
  TimeHelpers,
  Utilities
} from './functions.js';



====== .css files ======
--- /home/viihna/Projects/graphix/frontend/src/styles/index.css ---
/* File: frontend/src/styles/index.css */

@import url('./partials/variables.css');
@import url('./partials/keyframes.css');
@import url('./partials/media.css');

* {
  box-sizing: border-box;
}

body,
html {
  font-family: var(--font-stack-body);
  display: flex;
  flex-direction: column;
  margin: 0;
  padding: 0;
  height: 100vh;
  width: 100vw;
  overflow: hidden;
  align-items: center;
  background: var(--frosted-concrete);
}

#app {
  display: flex;
  flex-direction: column;
  width: 100vw;
  min-height: 100vh;
  background: var(--container-bg);
  overflow: hidden;
}

/* ============================================ */

header {
  flex: 0 0 auto;
  width: 100vw;
}

header h1 {
  margin: 0;
  padding: 0.75rem 0 0.75rem 0;
  font-size: clamp(2rem, 2vw, 1.08rem);
  font-family: var(--font-stack-header);
}

footer {
  flex: 0 0 auto;
  width: 100vw;
}

/* ============================================ */

#asset-browser {
  position: absolute;
  display: flex;
  right: 2rem;
  top: 6rem;
  z-index: 1000;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 16px;
  padding: 16px;
  box-shadow: 0 8px 32px var(--grape-soda-glow-80);
  flex-wrap: wrap;
  gap: 12px;
  min-width: 350px;
  max-width: 90vw;
  max-height: 65vh;
  overflow-y: auto;
  opacity: 0;
  pointer-events: none;
  transform: translateY(48px) scale(0.98);
  transition:
    opacity 0.32s cubic-bezier(0.25, 0.8, 0.25, 1),
    transform 0.32 cubic-bezier(0.25, 0.8, 0.25, 1);
}

#asset-browser.open {
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0) scale(1);
}

#canvas-container {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  max-height: 72vh;
  min-width: 900px;
  min-height: 280px;
  padding: 0 0 0 1rem;
  background: var(--canvas-cntr-bg-2);
  border: var(--border-2);
  border-radius: 0.5rem;
  box-shadow: 0 0 24px var(--bubblegum-pop-40);
  overflow: hidden;
  outline: 1px dashed green;
}

#graphic-preview-field {
  position: relative;
  display: flex;
  min-width: 240px;
  min-height: 56px;
  padding: 4px 10px;
  margin: 2px 0;
  align-items: center;
  justify-content: center;
  background-color: var(--angel-mist);
  border: var(--border-1);
  border-radius: 8px;
  box-shadow: var(--box-shadow-2);
  overflow: hidden;
  transition: var(--transition-1);
}

#graphic-text-span {
  filter: var(--filter-1);
}

#main-canvas {
  background: var(--vanilla-cream);
  max-width: 100%;
  border: var(--border-3);
  border-radius: 1rem;
  box-shadow: 0 8px 32px -4px var(--bubblegum-pop-70);
}

#graphic-text-span {
  font-family: var(--font-stack-graphic-text-default);
  font-weight: 800;
  font-size: clamp(1.1rem, 2.5vw, 1.75rem);
  letter-spacing: 0.05em;
  line-height: clamp(1.4rem, 3vw, 2.25rem);
}

#sparkle-checkbox-label {
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

#sparkle-overlay {
  position: absolute;
  pointer-events: none;
  z-index: 10;
  inset: 0;
  user-select: none;
  animation: var(--sparkle-overlay-animation);
}

#sticker-checkbox-label {
  font-size: clamp(1rem, 1.8vw, 1.125rem);
}

/* ============================================ */

.asset-browser img,
.asset-browser-thumb {
  width: 70px;
  height: 70px;
  object-fit: contain;
  margin: 8px;
  border-radius: 10px;
  box-shadow: 0 2px 8px var(--bubblegum-pop-80);
  background: var(--vanilla-cream);
  transition:
    box-shadow 0.15s,
    transform 0.15s;
}

.assetBrowserThumb:hover {
  box-shadow: 0 4px 18px var(--grape-soda-glow-80);
  transform: scale(1.1) rotate(-2deg);
}

.canvas-field {
  display: flex;
  grid-area: center;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  gap: 1rem;
  outline: 1px dashed blue;
}

.canvas-toolbar {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  max-width: 220px;
  margin: 1.5rem auto 2rem auto;
  background: var(--p_white-33);
  border-radius: 1rem;
  box-shadow: var(--box-shadow-1);
  backdrop-filter: blur(2px);
  filter: var(--filter-2);
  padding: 1.1rem 0.2rem;
  gap: 1.1rem;
}

.flex-col {
  display: flex;
  flex-direction: column;
}

.footer-div {
  width: 100%;
  max-height: 25px;
  padding: 1rem 0 1.1rem 0;
  background: var(--container-bg);
  border-radius: 1.1rem 1.1rem 0 0;
  box-shadow: 0 -2px 24px var(--bubblegum-pop-30);
  outline: 1px dashed rgb(227, 41, 72);
  text-align: center;
  font-size: 1.1rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

.header-div {
  width: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  outline: 1px dashed black;
}

.hidden {
  display: none;
}

.main-area {
  flex: 1 0 auto;
  display: flex;
  flex-direction: column;
  width: 100vw;
  min-height: 0;
}

.main-div {
  flex: 1 1 auto;
  display: grid;
  grid-template-columns: 1fr 340px;
  grid-template-areas: 'center right';
  width: 100%;
  max-width: 1280px;
  margin: 0 auto;
  gap: 2.4rem;
  align-items: center;
  justify-content: center;
  min-height: 0;
}

.sparkle {
  animation: sparkleColor 2.5s linear infinite alternate;
}

.tray {
  background: var(--p_white-bf);
  text-align: center;
  width: 100%;
  max-width: 200px;
  padding: 1.2rem 0.8rem 1.8rem;
  margin-top: 1.5rem;
  border-radius: 1rem;
  box-shadow: 0 2px 24px var(--bubblegum-pop-30);
}

.tray--extras {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  max-width: 1240px;
  min-width: 180px;
  margin: 0 auto;
  padding-bottom: 2.5rem;
  grid-area: right;
}

.tray--stickers {
  outline: 1px dashed purple;
}

/* ============================================ */

#canvas-container::before {
  content: '';
  position: absolute;
  inset: 0;
  pointer-events: none;
  background: url('/assets/decor/sparkle-overlay.png') repeat;
  opacity: 0.12;
  z-index: 5;
  animation: sparkleMove 10s linear infinite;
}

#sticker-tray-heading,
.tray--extras h2 {
  font-size: clamp(1.25rem, 3vw, 1.6rem);
  color: var(--purple-reign);
  letter-spacing: 0.03em;
  text-shadow: 0 1px 4px var(--bubblegum-pop-66);
  margin-bottom: 0.7em;
}

.canvas-toolbar button {
  font-size: 1.08rem;
}

.tray--extras,
#properties-panel {
  outline: 1px dashed orange;
}

--- /home/viihna/Projects/graphix/frontend/src/styles/main.css ---
/* File: frontend/src/styles/main.css */

@import url('./partials/variables.css');
@import url('./partials/keyframes.css');
@import url('./partials/media.css');
@import url('./index.css');
@import url('./partials/components/buttons.css');

--- /home/viihna/Projects/graphix/frontend/src/styles/partials/components/buttons.css ---
/* File: frontend/src/styles/partials/components/buttons.css */

@import url('../variables.css');

.canvas-btn {
  width: 90%;
  max-width: 200px;
  min-width: 120px;
  margin: 0 auto;
  font-size: 1rem;
  padding: 0.65rem 0;
  border-radius: 0.6rem;
  box-shadow:
    0 4px 24px -6px var(--bubblegum-pop-80),
    0 1.5px 6px -4px var(--p_black-11);
  transition:
    background 0.22s,
    transform 0.16s,
    box-shadow 0.22s;
  cursor: pointer;
  border-radius: 0.4rem;
  font-family: 'Courier New', Courier, monospace;
  letter-spacing: 0.15rem;
  color: var(--pastel-heart-rose);
  background: var(--grape-soda-glow-80);
  text-shadow: 2px 4px 2px #00000020;
}

.canvas-btn:hover {
  background-color: var(--ultraviolet-slap);
}

.canvas-btn:focus,
.canvas-btn:focus-visible {
  outline: var(--btn-focus-outline-1);
  outline-offset: 2px;
  box-shadow: var(--bubblegum-pop-80);
}

.canvas-btn:hover,
.canvas-btn:focus {
  background: linear-gradient(
    90deg,
    var(--electric-rose) 0%,
    var(--dreamcore-indigo) 100%
  );
  transform: translateY(-2px) scale(1.04) rotate(-1deg);
  box-shadow:
    0 8px 28px -6px var(--grape-soda-glow-80),
    0 2.5px 10px -4px var(--p_white-33);
}

--- /home/viihna/Projects/graphix/frontend/src/styles/partials/keyframes.css ---
/* File: frontend/src/styles/partials/keyframes.css */

@import url('./variables.css');

/* =================================================== */

@keyframes sparkleColor {
  0% {
    filter: var(--drop-shadow-1) var(--drop-shadow-2) brightness(1.1);
  }
  50% {
    filter: var(--drop-shadow-3) var(--drop-shadow-4) brightness(1.3);
  }
  100% {
    filter: var(--drop-shadow-5) var(--drop-shadow-6) brightness(1.15);
  }
}

@keyframes pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@keyframes sparkleMove {
  0% {
    background-position: 0 0;
  }
  100% {
    background-position: 120px 120px;
  }
}

--- /home/viihna/Projects/graphix/frontend/src/styles/partials/media.css ---
/* File: frontend/src/styles/partials/media.css */

@media (min-width: 768px) {
  #graphic-preview-field {
    min-width: 320px;
    min-height: 72px;
    padding: 8px 16px;
  }
  #graphic-text-span {
    font-size: 1.875rem;
    line-height: 2.25rem;
  }
  #sparkle-checkbox-label {
    font-size: 1.25rem;
  }
  .canvas-io-btn {
    padding: 0.7rem 0;
    font-size: 1.14rem;
  }
}

@media (max-width: 900px) {
  .main-area {
    grid-template-columns: 1fr;
    grid-template-areas: 'center' 'right';
  }
  .main-div {
    grid-template-columns: 1fr;
    grid-template-areas: 'center' 'right';
    gap: 1.2rem;
  }
  .tray--extras {
    margin-top: 2rem;
  }
}

@media (max-width: 1024px) {
  .canvas-io-btn {
    padding: 0.75rem 0;
    font-size: 1.22rem;
  }
  .main-area {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  .tray {
    margin: 1.5rem 0;
  }
}

--- /home/viihna/Projects/graphix/frontend/src/styles/partials/variables.css ---
/* File: frontend/src/styles/partials/variables.css */

:root {
  --font-stack-header: 'Impact', 'Arial Black', 'Bangers', Arial, sans-serif;
  --font-stack-body: 'Trebuchet MS', Verdana, Arial, sans-serif;
  --font-stack-goth: 'Creepster', 'Georgia', 'Papyrus', serif;
  --font-stack-mono: 'Courier New', 'Lucida Console', monospace;
  --font-stack-script: 'Lobster', 'Comic Sans MS', 'Monotype Corsiva', cursive;
  --font-stack-graphic-text-default:
    ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono';
  --canvas-io-btn-font-stack: 'Arial Black', cursive, sans-serif;
}

/* ============================================= */

:root {
  --angel-mist: #f7deeae6;
  --arcadian-pink: #e879f9;
  --baby-blueberry: #b7c8f7;
  --bubblegum-pop: #e879f9;
  --cloud-shadow: #00ffff;
  --cotton-candy-pink: #fff1f7;
  --dandelion-fluff: #ffffee;
  --disco-orchid: #ff80c5;
  --dream-bubble: #dbeafe;
  --dreamcore-indigo: #6366f1;
  --electric-rose: #f472b6;
  --frosted-concrete: #dddddd;
  --frosted-rose-quartz: #e979f9;
  --glacier-cream: #b7c8f7;
  --grape-soda-glow: #c026d3;
  --indigo-riot: #5a00d2;
  --lavender-sky: #a5b4fc;
  --lavender-whisper: #e9d5ff;
  --limoncello-flash: #ffff00;
  --magenta-haze: #ff00ff;
  --orchid-dream: #ff80cf;
  --pastel-heart-rose: #fff1f7;
  --petal-mist: #fff1f7;
  --purple-reign: #a21caf;
  --rosewater-milkshake: #fce7f3;
  --strawberry-frost: #f9a8d4;
  --ultraviolet-slap: #c026d3;
  --vanilla-cream: #fffbe6;
}

/* ============================================= */

:root {
  --bubblegum-pop-30: #e879f930;
  --bubblegum-pop-40: #e879f940;
  --bubblegum-pop-66: #e879f966;
  --bubblegum-pop-70: #e879f970;
  --bubblegum-pop-80: #e879f980;
  --cloud-shadow-88: #00ffff88;
  --disco-orchid-aa: #ff80c5aa;
  --grape-soda-glow-80: #c026d380;
  --limoncello-flash-dd: #ffff00dd;
  --magenta-haze-88: #ff00ff88;
}

/* ============================================= */

:root {
  --p_black: #000000ff;
  --p_black-11: #00000011;
  --p_black-1a: #0000001a;
  --p_black-33: #00000033;
  --p_black-40: #00000040;

  --p_white: #ffffffff;
  --p_white-33: #ffffff33;
  --p_white-88: #ffffff88;
  --p_white-bf: #ffffffbf;
}

/* ============================================= */

:root {
  --font-size-sm: 0.875rem;
}

/* ============================================= */

:root {
  --border-1: 2px solid var(--frosted-rose-quartz);
  --border-2: 2px solid var(--orchid-dream);
  --border-3: 3px dashed var(--indigo-riot);
  --border-4: 4px dashed var(--purple-reign);
}

/* ============================================= */

:root {
  --filter-1: drop-shadow(0 1px 1px var(--p_black-33));
  --filter-2: drop-shadow(0 2px 36px var(--bubblegum-pop-66));
}

/* ============================================= */

:root {
  --sparkle-overlay-animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* ============================================= */

:root {
  --btn-focus-outline-1: 3px solid var(--strawberry-frost);
}

/* ============================================= */

:root {
  --transition-1: all 0.2s ease;
}

/* ============================================= */

:root {
  --box-shadow-1:
    0 10px 15px -3px var(--p_black-1a), 0 4px 6px -4px var(--p_black-1a);
  --box-shadow-2: 0 25px 50px -12px var(--p_black-40);
  --box-shadow-3: 0 0 48px var(--disco-orchid-aa);
  --box-shadow-4: 0 0 48px var(--disco-orchid-aa);

  --drop-shadow-1: 0 0 12px var(--p_white-88);
  --drop-shadow-2: 0 0 3px var(--limoncello-flash-dd);
  --drop-shadow-3: 0 0 24px var(--dandelion-fluff);
  --drop-shadow-4: 0 0 10px var(--magenta-haze-88);
  --drop-shadow-5: 0 0 16px var(--magenta-haze);
  --drop-shadow-6: 0 0 4px var(--cloud-shadow-88);
}

/* ============================================= */

:root {
  --text-shadow-1:
    0 2px 10px var(--p_white), 0 2px 16px var(--bubblegum-pop),
    0 1px 10px var(--lavender-sky);
}

/* ============================================= */

:root {
  --canvas-cntr-bg-1: linear-gradient(
    135deg,
    var(--cotton-candy-pink) 0%,
    var(--baby-blueberry) 100%
  );

  --canvas-cntr-bg-2: linear-gradient(
    135deg,
    var(--petal-mist) 0%,
    var(--glacier-cream) 100%
  );

  --container-bg: linear-gradient(
    to bottom right,
    var(--rosewater-milkshake),
    var(--dream-bubble),
    var(--lavender-whisper)
  );
}

